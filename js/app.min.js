/*!
 * Lifey. version 0.1.1
 * Copyright 2016 Benjamin Lord.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var Flingable = __webpack_require__(1);
	var Resizable = __webpack_require__(2);
	var ut = __webpack_require__(3);
	var Modal = __webpack_require__(4);
	var modalCanvasSize = __webpack_require__(6);
	var modalOpenPattern = __webpack_require__(7);
	var modalSavePattern = __webpack_require__(10);
	var modalSharePattern = __webpack_require__(11);
	var parseRLEPixelString = __webpack_require__(12);
	var parseBMP = __webpack_require__(9);
	var patToRleFileString = __webpack_require__(13);
	var dataArrayToRLE = __webpack_require__(14);
	var saveTextAsFile = __webpack_require__(15);
	var Hammer = __webpack_require__(16);
	
	// Tooltips imports Gator for easy event delegation.
	__webpack_require__(17);
	
	// Note: Don't use the broken version of Keymaster on npm.
	// Lifey uses a modified version based on a fork of Keymaster which
	// supports direct binding to single modifier keys e.g. "shift":
	// https://github.com/madrobby/keymaster/pull/136
	// (The local version in modules also has other es6-related changes,
	// including not binding to window etc.)
	var key = __webpack_require__(5);
	
	//*******************************************
	//*******
	//******* ---- Elements ----
	//*******
	//*******************************************
	
	var w = window;
	var doc = document;
	
	var htmlEl = doc.documentElement;
	var bodyEl = doc.body;
	
	var scrollSs = doc.querySelector("#scroll-stylesheet").sheet;
	
	var outerBgEl = doc.querySelector(".outer-background");
	var innerViewEl = doc.querySelector(".inner-background");
	var canvasEl = doc.querySelector(".main-canvas");
	var canvasCtx = canvasEl.getContext("2d");
	
	var splashEl = doc.querySelector(".splash");
	
	var navCanvasEl = doc.querySelector(".navigator__canvas");
	var navCanvasCtx = navCanvasEl.getContext("2d");
	var navOutlineEl = doc.querySelector(".navigator__canvas-outline");
	
	var toolboxEl = doc.querySelector("[data-toolbox]");
	var toolboxButtonEls = doc.querySelectorAll(".toolbox__button");
	
	var infoCursorXEl = doc.querySelector("[data-info-cursor-position-x]");
	var infoCursorYEl = doc.querySelector("[data-info-cursor-position-y]");
	var infoDimensionXEl = doc.querySelector("[data-info-dimension-x]");
	var infoDimensionYEl = doc.querySelector("[data-info-dimension-y]");
	var infoCanvasSizeButtonEl = doc.querySelector("[data-info-button='resize']");
	
	var playerPanelEl = doc.querySelector(".player");
	var playerToroidalWrapperEl = doc.querySelector(".player__toroidal");
	var playerToroidalInputEl = doc.querySelector("[data-player-toroidal]");
	var playerSpeedEl = doc.querySelector("[data-player-speed]");
	var playerSpeedInputEl = doc.querySelector("[data-player-speed-input]");
	var playerCounterEl = doc.querySelector("[data-generations-counter]");
	var playerClearButtonEl = doc.querySelector("[data-player-button='clear']");
	var playerResetButtonEl = doc.querySelector("[data-player-button='reset']");
	var playerPlayButtonEl = doc.querySelector("[data-player-button='play']");
	var playerStepButtonEl = doc.querySelector("[data-player-button='step']");
	
	var patternsPanelEl = doc.querySelector(".patterns");
	var patternsOuterWrapperEl = doc.querySelector(".patterns__outer-wrapper");
	var patternsOpenButtonEl = doc.querySelector("[data-pattern-button=open]");
	var patternsSaveButtonEl = doc.querySelector("[data-pattern-button=save]");
	var patternsShareButtonEl = doc.querySelector("[data-pattern-button=share]");
	var patternsWrapperEl = doc.querySelector(".patterns__outer-wrapper");
	var patternsListItemEls = doc.querySelectorAll(".pat");
	
	// Mobile-only UI
	var meterButtonMobileEl = doc.querySelector(".meter__mobile-button");
	var menuButtonMobileEl = doc.querySelector(".menu__mobile-button");
	var patternsButtonMobileEl = doc.querySelector(".patterns__mobile-button");
	var requestFullscreenButtonEl = doc.querySelector(".mobile-menu__go-fullscreen");
	var exitFullscreenButtonEl = doc.querySelector(".mobile-menu__exit-fullscreen");
	
	// All panels
	var panelArray = [doc.querySelector("[data-toolbox]"), doc.querySelector("[data-navigator]"), doc.querySelector("[data-info]"), doc.querySelector("[data-player]"), doc.querySelector("[data-patterns]")];
	
	//*******************************************
	//*******
	//******* ---- Browser Specifics/Feature detects ----
	//*******
	//*******************************************
	
	// Note: window.browser is already defined in the <head> for detects and avoiding FOUC.
	
	// Safari currently "supports" the 'webkit-crisp-edges' value on CSS
	// image-rendering, but doesn't actually render it for <canvas> elements.
	// Because it's a false positive, it's hard to test for.
	// Use crummy vendor detection for now until Apple fixes it.
	w.browser = w.browser || Object.create(null);
	w.browser.isSafari = navigator.vendor && navigator.vendor.indexOf("Apple") > -1;
	
	// Modern Opera also uses this value.
	w.browser.isBlink = navigator.vendor && navigator.vendor === "Google Inc.";
	
	w.browser.isMac = navigator.platform && navigator.platform.toUpperCase().indexOf("MAC") >= 0;
	
	w.browser.shortkey = browser.isMac ? "âŒ˜" : "ctrl";
	
	w.browser.isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
	
	// TO DO: INSERT Polyfill for lack of current Firefox support.
	// See https://bugzilla.mozilla.org/show_bug.cgi?id=960316
	// The document root should never scroll/overscroll.
	// (For now FF seems to work without this.)
	// if ( !( "touchAction" in document.documentElement.style ) ) {
	// }
	
	//*******************************************
	//*******
	//******* ---- State ----
	//*******
	//*******************************************
	
	var state = Object.create(null);
	state.userIsDrawing = false;
	state.pointerIsHoveringResizableEdge = false;
	
	state.innerView = Object.create(null);
	state.innerView.dragPageStart = Object.create(null);
	state.innerView.dragScrollStart = Object.create(null);
	state.innerView.isDragging = false;
	state.innerView.mouseIsDown = false;
	
	// Scroll values are initially undefined because initial view always fit in window.
	state.innerView.scroll = Object.create(null);
	
	state.canvas = Object.create(null);
	state.canvas.overflowsInnerView = false;
	state.canvas.domDim = Object.create(null);
	state.canvas.scale = 6; // Initially match the CSS transform scale() in CSS.
	
	state.toolbox = Object.create(null);
	state.toolbox.tool = "brush";
	state.toolbox.selectedButton = doc.querySelector(".toolbox__button"); // Brush is first
	
	state.nav = Object.create(null);
	state.nav.canvas = Object.create(null);
	state.nav.outline = Object.create(null);
	state.nav.outline.posX = 0;
	state.nav.outline.posY = 0;
	state.nav.outline.percentageX = 1; // 100% initial.
	state.nav.outline.percentageY = 1;
	
	state.player = Object.create(null);
	state.player.isPlaying = false;
	state.player.toroidal = false; // Initially unchecked.
	state.player.generation = 0;
	state.player.delay = 500; // Initially the input type=range slider is in the middle.
	
	state.patterns = Object.create(null);
	
	state.scrollbarDim = 0; // Assume zero until load.
	
	var nextFrameID = void 0; // Timeouts set in the player.
	
	//*******************************************
	//*******
	//******* ---- Flingable and Resizable Panels ----
	//*******
	//*******************************************
	
	// Make each panel Flingable except for the last panel (patterns).
	for (var i = 0; i < 4; i += 1) {
		var panelElement = panelArray[i];
		Object.create(Flingable).initFlingable(panelElement, {
			flingCoast: false,
			flingContainer: bodyEl,
			flingHandleEl: panelElement.querySelector("[data-flingable-handle]")
		});
	}
	
	// Pattern panel is uniquely both Flingable and Resizable.
	var patternPanel = Object.create(ut.extend(Object.create(Flingable), Resizable));
	
	patternPanel.rzblAbortResize = function () {
		return state.canvas.isDrawing || state.isModalOpen; // Prevents resize handle behaviors.
	};
	
	patternPanel.reportResizing = function (isResizing) {
		state.panelIsResizing = isResizing; // Set state when an edge is being resized.
	};
	
	patternPanel.initFlingable(panelArray[4], {
		flingCoast: false,
		flingContainer: bodyEl,
		flingHandleEl: panelArray[4].querySelector("[data-flingable-handle]")
	}).initResizable(panelArray[4], {
		rzblTop: false,
		rzblHorizontalCssProp: "right"
	});
	
	//*******************************************
	//*******
	//******* ---- Prevent Default on Panel drag
	//*******
	//*******************************************
	
	// Suppresses the default I-beam cursor when user is mistakenly trying to drag
	// by something other than the "panel__dragspot".
	Gator(bodyEl).on(["mousedown"], ".panel", function (e) {
		e.preventDefault();
	});
	
	//*******************************************
	//*******
	//******* ---- innerView ----
	//*******
	//*******************************************
	
	var innerView = {
		getVisibleDimensions: function getVisibleDimensions() {
	
			// The outer background dimensions, minus any scrollbars. offsetDim includes scrollbars.
			// state.innerView.visibleWidth = outerBgEl.clientWidth - state.scrollbarDim;
			// state.innerView.visibleHeight = outerBgEl.clientHeight - state.scrollbarDim;
			state.innerView.visibleWidth = outerBgEl.clientWidth;
			state.innerView.visibleHeight = outerBgEl.clientHeight;
		},
	
		onResize: function onResize() {
			innerView.getVisibleDimensions();
			canvas.evaluateOverflow(); // Will set dimensions if goes into overflow.
		},
	
		onScroll: function onScroll() {
			if (state.innerView.isDragging) {
				return; // Bail out, drag memoizes scroll position on its own,
				// and the debounce breaks it.
			}
	
			state.innerView.scroll.x = state.innerView.dragScrollStart.x = this.scrollLeft;
			state.innerView.scroll.y = state.innerView.dragScrollStart.y = this.scrollTop;
	
			updateNavOutline(false);
		},
	
		setScrollPosition: function setScrollPosition(x, y) {
			if (!state.canvas.overflowsInnerView) {
				return;
			}
	
			// TO-DO: limit the height to max?
			x = Math.max(0, x);
			y = Math.max(0, y);
	
			outerBgEl.scrollLeft = state.innerView.scroll.x = x;
			outerBgEl.scrollTop = state.innerView.scroll.y = y;
		},
	
		onPointerDown: function onPointerDown(e) {
	
			if (!state.canvas.overflowsInnerView || browser.isBig && !key.shift && state.toolbox.tool !== "hand" || !browser.isBig && state.toolbox.tool !== "zoom-in") {
				return; // Get out, don't handle drag by scrolling.
			}
	
			state.innerView.dragPageStart.x = e.pageX;
			state.innerView.dragPageStart.y = e.pageY;
	
			// Record the initial scroll position at the start of the drag.
			// This is the only place where this property get written.
			state.innerView.dragScrollStart.x = state.innerView.scroll.x;
			state.innerView.dragScrollStart.y = state.innerView.scroll.y;
			state.innerView.isDragging = true;
	
			bodyEl.addEventListener("mousemove", innerView.onDragMove);
			bodyEl.addEventListener("mouseleave", innerView.onDragEnd);
			bodyEl.addEventListener("mouseup", innerView.onDragEnd);
		},
	
		onDragMove: function onDragMove(e) {
			var pageX = e.pageX;
			var pageY = e.pageY;
	
			var moveX = pageX - state.innerView.dragPageStart.x;
			var moveY = pageY - state.innerView.dragPageStart.y;
	
			// Set on DOM. These values get clamped by scroll endpoints.
			outerBgEl.scrollLeft = state.innerView.dragScrollStart.x - moveX;
			outerBgEl.scrollTop = state.innerView.dragScrollStart.y - moveY;
	
			// Read clamped value back into memory for the navigator to use.
			// Fix this to be cleaner later.
			state.innerView.scroll.x = outerBgEl.scrollLeft;
			state.innerView.scroll.y = outerBgEl.scrollTop;
	
			if (browser.isBig) {
				w.setTimeout(function () {
					updateNavOutline(false);
				}, 0);
			}
		},
	
		onDragEnd: function onDragEnd(e) {
			state.innerView.isDragging = false;
	
			bodyEl.removeEventListener("mousemove", innerView.onDragMove);
			bodyEl.removeEventListener("mouseleave", innerView.onDragEnd);
			bodyEl.removeEventListener("mouseup", innerView.onDragEnd);
	
			// Read values back from Dom into memory, to normalize for min/max values
			state.innerView.scroll.x = outerBgEl.scrollLeft;
			state.innerView.scroll.y = outerBgEl.scrollTop;
		}
	};
	
	// ---- innerView Bindings are added on page load, below.
	// Firefox on Android can fire mysterious early resize events which cause trouble.
	
	//*******************************************
	//*******
	//******* ---- Canvas ----
	//*******
	//*******************************************
	
	var canvas = Object.create(null);
	
	canvas.setCanvasDim = function (x, y) {
		state.canvas.domDim.x = canvasEl.width = x;
		state.canvas.domDim.y = canvasEl.height = y;
	
		// Turning off canvas image smoothing shouldn't really matter,
		// but there may be a very slight performance gain:
		// https://jsperf.com/imagesmoothingenabled
		// image smoothing must be reset after resize.
		canvasCtx.imageSmoothingEnabled = false;
	
		// Whenever a new canvas dimension is specified. Temporarily reset to white
		// on eraser mousedown on canvas.
		canvasCtx.fillStyle = "rgba(0,0,0,1)";
		navCanvasCtx.fillStyle = "rgba(0,0,0,1)";
	
		canvas.clearMainAndNavCanvases();
		canvas.setNavigatorCanvasDimensions();
	
		// Set the user-displayed dimensions in the Info panel.
		infoDimensionXEl.textContent = x;
		infoDimensionYEl.textContent = y;
	
		// Allows optimized fast 2d drawing in the render loop. See:
		// https://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays/
		state.canvas.imageData = canvasCtx.getImageData(0, 0, x, y);
		state.canvas.pixelBuffer = new Int32Array(state.canvas.imageData.data.buffer);
	};
	
	canvas.setNavigatorCanvasDimensions = function () {
		var containerMaxWidth = 158;
		var containerMaxHeight = 164;
		var mainCanvasX = state.canvas.domDim.x;
		var mainCanvasY = state.canvas.domDim.y;
		var navWidth = void 0,
		    navHeight = void 0;
		var containerAspectRatio = containerMaxWidth / containerMaxWidth;
		var canvasAspectRatio = mainCanvasX / mainCanvasY;
	
		// Always maximize nav canvas within the nav container regardless of main canvas dimensions.
	
		// The wide case.
		if (canvasAspectRatio >= containerAspectRatio) {
			navWidth = containerMaxWidth;
			navHeight = Math.round(containerMaxWidth / canvasAspectRatio);
	
			// The tall case.
		} else {
			navWidth = Math.round(containerMaxHeight * canvasAspectRatio);
			navHeight = containerMaxHeight;
		}
	
		// Inline styles
		navCanvasEl.style.width = navWidth + "px";
		navCanvasEl.style.height = navHeight + "px";
	
		// Stored state.
		state.nav.canvas.width = navWidth;
		state.nav.canvas.height = navHeight;
	
		// Navigator Canvas Dom Dimensions match the main canvas.
		// This is more efficient for the player loop.
		navCanvasEl.width = mainCanvasX;
		navCanvasEl.height = mainCanvasY;
	
		// Must be reset after resize.
		// Keeps the navigator canvas from being blurry when the main canvas is tiny.
		// Otherwise keep smoothing on because it generally looks better.
		if (mainCanvasX <= containerMaxWidth && mainCanvasY <= containerMaxHeight) {
			navCanvasCtx.imageSmoothingEnabled = false;
		}
	};
	
	canvas.clearDataArray = function () {
		state.canvas.dataArray = new Int8Array(state.canvas.domDim.x * state.canvas.domDim.y);
	};
	
	canvas.clearMainAndNavCanvases = function () {
		var cWidth = state.canvas.domDim.x;
		var cHeight = state.canvas.domDim.y;
		canvasCtx.clearRect(0, 0, cWidth, cHeight);
		navCanvasCtx.clearRect(0, 0, cWidth, cHeight);
	};
	
	// Commented out but preserve for performance checking.
	var paintBothCanvasesPerfCounter = 0;
	var paintBothCanvasesDuration = 0;
	
	canvas.paintBothCanvasesBitwise = function () {
	
		// Performance checking Main paint start.
		var paintBothCanvasesStart = performance.now();
	
		var dataArr = state.canvas.dataArray;
		var len = dataArr.length;
		var canvasWidth = state.canvas.domDim.x;
	
		// Thanks to:
		// https://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays/
		// Note however that 32-bit direct manipulation is actually fastest. See:
		// http://jsperf.com/canvas-pixel-manipulation/8
	
		var pixels = state.canvas.pixelBuffer;
	
		for (var _i = 0; _i < len; _i += 1) {
	
			// Convert 1 (live) to 0. Convert 0 (dead) to 255.
			var value = 255 - dataArr[_i] * 255;
	
			pixels[_i] = 255 << 24 | /* alpha always opaque*/
			value << 16 | /* blue */
			value << 8 | /* green */
			value; /* red */
		}
	
		canvasCtx.putImageData(state.canvas.imageData, 0, 0);
		navCanvasCtx.putImageData(state.canvas.imageData, 0, 0);
	
		// Performance checking Main paint end.
		var paintBothCanvasesEnd = performance.now();
		paintBothCanvasesDuration += paintBothCanvasesEnd - paintBothCanvasesStart;
		if (paintBothCanvasesPerfCounter === 59) {
			console.log("Avg canvas.paintBothCanvasesBitwise: " + paintBothCanvasesDuration / 60 + " ms.");
			paintBothCanvasesPerfCounter = 0;
			paintBothCanvasesDuration = 0;
		}
		paintBothCanvasesPerfCounter += 1;
	};
	
	canvas.draw = function (e) {
		var cWidth = state.canvas.domDim.x;
		var cHeight = state.canvas.domDim.y;
		var sc = state.canvas.scale;
		var scrollX = state.innerView.scroll.x;
		var scrollY = state.innerView.scroll.y;
		var arrayVal = 1; // Assume paint.
		var pageX = void 0,
		    pageY = void 0,
		    targetOffsetLeft = void 0,
		    targetOffsetTop = void 0,
		    transOffsetLeft = void 0,
		    transOffsetTop = void 0,
		    x = void 0,
		    y = void 0;
	
		if (e.type === "touchmove") {
			e.preventDefault();
		} // Prevent simulated mouse events.
		if (key.shift) {
			return;
		} // Don't draw anything if shift is held.
	
		// Note: clearRect() sometimes leaves ghosting in Blink. Yes, using integers. ARGH!
		// Erase on the main canvas by painting with opaque white instead.
		// This is super ugly but it's the only way to get clean whites.
	
		// Changing the destination mode only works for true 2D erasing. Saving this for
		// future reference though:
		// canvasCtx.globalCompositeOperation = "source-over";
		// canvasCtx.globalCompositeOperation = "destination-out";
	
		// Note that these fill styles will need to be reset to black on mouseup/touchend,
		// otherwise the player won't work.
		if (state.toolbox.tool === "eraser") {
			arrayVal = 0;
			canvasCtx.fillStyle = "rgba(255,255,255,1)";
			navCanvasCtx.fillStyle = "rgba(255,255,255,1)";
		}
	
		// Handle multitouch drawing/erasing.
		var pointerCount = e.targetTouches && e.targetTouches.length || 1;
		var pointerArray = [];
	
		// Synthesize offsetX / Y for all drawing, including mouse.
	
		for (var _i2 = 0; _i2 < pointerCount; _i2 += 1) {
	
			// Emulate/synthesize offsetX and offsetY event properties for touch events.
			if (e.type === "touchstart" || e.type === "touchmove") {
				pageX = e.touches[_i2].pageX;
				pageY = e.touches[_i2].pageY;
				targetOffsetLeft = e.touches[_i2].target.offsetLeft;
				targetOffsetTop = e.touches[_i2].target.offsetTop;
			} else {
				pageX = e.pageX;
				pageY = e.pageY;
				targetOffsetLeft = e.target.offsetLeft;
				targetOffsetTop = e.target.offsetTop;
			}
	
			transOffsetLeft = targetOffsetLeft - (cWidth * sc - cWidth) / 2;
			transOffsetTop = targetOffsetTop - (cHeight * sc - cHeight) / 2;
	
			x = (pageX - transOffsetLeft) / sc;
			y = (pageY - transOffsetTop) / sc;
	
			// Need to check before compensating for scroll.
			// Scroll values are undefined when canvas fits in innerView.
			if (scrollX) {
				x += scrollX / sc;
			}
			if (scrollY) {
				y += scrollY / sc;
			}
	
			// Lastly adjust for the "auto" left margin value created on
			// tall overflowing canvases.
			pointerArray[_i2] = {
				x: Math.floor(x - state.innerView.marginLeft / sc),
				y: Math.floor(y)
			};
		}
	
		for (var j = 0; j < pointerCount; j += 1) {
			var drawX = pointerArray[j].x;
			var drawY = pointerArray[j].y;
	
			// Note: fillRect() is fastest on modern browsers
			// http://jsperf.com/setting-canvas-pixel
			canvasCtx.fillRect(drawX, drawY, 1, 1);
			navCanvasCtx.fillRect(drawX, drawY, 1, 1);
			state.canvas.dataArray[drawY * state.canvas.domDim.x + drawX] = arrayVal;
		}
	};
	
	canvas.onPointerDown = function (e) {
	
		// Early return for non-drawing modes.
		if (state.toolbox.tool !== "brush" && state.toolbox.tool !== "eraser" || // E.g. hand, zoom
		state.toolbox.override || // Hand keyboard shortcut state.
		state.panelIsResizing || // On canvas but resizing a panel.
		state.isHoveringResizableEdge || // On canvas but near a drag-resizable edge. TO DO?
		state.isModalOpen || e.which === 3) {
			// Right mouse click shouldn't paint.
	
			return;
		}
	
		// Keep below early return.
		// Don't prevent default regular native inertial touch-dragging.
		if (e.type === "touchstart") {
			e.preventDefault();
		}
	
		// Read and stored for draw positioning when canvas is narrow but overflows vertically,
		// and width is less than the inner view width minus all horizontal padding.
		state.innerView.marginLeft = parseInt(w.getComputedStyle(innerViewEl).marginLeft, 10);
	
		// Drawing on top of a pattern in the library deselects that pattern.
		voidCurrentSelectedPatternLink();
		clearAnyHash();
	
		canvas.draw(e);
		state.canvas.isDrawing = true;
	
		if (e.type === "touchstart") {
			canvasEl.addEventListener("touchmove", canvas.draw);
			w.addEventListener("touchend", canvas.onPointerUp);
		} else {
			// Assume mouse.
			canvasEl.addEventListener("mousemove", canvas.draw);
			w.addEventListener("mouseup", canvas.onPointerUp);
		}
	};
	
	canvas.onPointerUp = function (e) {
		state.canvas.isDrawing = false;
	
		// Canvas fill style must be reset to black on end of eraser (white draw)
		// so that player drawing will work.
		if (state.toolbox.tool === "eraser") {
			canvasCtx.fillStyle = "rgba(0,0,0,1)";
			navCanvasCtx.fillStyle = "rgba(0,0,0,1)";
		}
	
		if (e.type === "touchend") {
			e.preventDefault();
			canvasEl.removeEventListener("touchmove", canvas.draw);
			w.removeEventListener("touchend", canvas.onPointerUp);
		} else {
			// Assume mouse.
			canvasEl.removeEventListener("mousemove", canvas.draw);
			w.removeEventListener("mouseup", canvas.onPointerUp);
		}
	};
	
	canvas.handleResize = function (newWidth, newHeight, anchorX, anchorY) {
		var oldWidth = state.canvas.domDim.x;
		var oldHeight = state.canvas.domDim.y;
	
		var oldDataArray = state.canvas.dataArray;
		var newDataArray = new Int8Array(newWidth * newHeight);
	
		// The amount to crop out from the origin (left, top) sides of the original.
		// If the new dims are bigger, there will be no crop, and offset will be 0.
		// If the new dims are smaller, offset will be a positive integer.
		// These are only used to determine where the loop starts.
		var oldCenterMap = Object.create(null, {
			left: { value: 0 },
			center: { value: Math.round(Math.max(oldWidth - newWidth, 0) / 2) },
			right: { value: Math.max(oldWidth - newWidth, 0) },
			top: { value: 0 },
			middle: { value: Math.round(Math.max(oldHeight - newHeight, 0) / 2) },
			bottom: { value: Math.max(oldHeight - newHeight, 0) }
		});
	
		var oldXOffset = oldCenterMap[anchorX];
		var oldYOffset = oldCenterMap[anchorY];
	
		// The endpoint of the loop will be the smaller of the current and new dims.
		var xLen = oldXOffset + Math.min(oldWidth, newWidth);
		var yLen = oldYOffset + Math.min(oldHeight, newHeight);
	
		// These offsets handle the cases when the new canvas is bigger.
		// Handling these separately keeps the loop clean.
		var newCenterMap = Object.create(null, {
			left: { value: 0 },
			center: { value: Math.round(Math.max(newWidth - oldWidth, 0) / 2) },
			right: { value: Math.max(newWidth - oldWidth, 0) },
			top: { value: 0 },
			middle: { value: Math.round(Math.max(newHeight - oldHeight, 0) / 2) },
			bottom: { value: Math.max(newHeight - oldHeight, 0) }
		});
	
		var newXOffset = newCenterMap[anchorX];
		var newYOffset = newCenterMap[anchorY];
	
		// Loop through all (or part) of the old dataArray,
		// applying it with an offset to the newDataArray.
		for (var _i3 = oldYOffset; _i3 < yLen; _i3 += 1) {
			for (var j = oldXOffset; j < xLen; j += 1) {
				newDataArray[(_i3 - oldYOffset + newYOffset) * newWidth + (j - oldXOffset + newXOffset)] = oldDataArray[_i3 * oldWidth + j];
			}
		}
	
		state.canvas.dataArray = newDataArray;
	
		// Don't reset generations counter on canvas resize.
		redrawCanvasFromDataArray(newDataArray, newWidth, newHeight);
	};
	
	//
	// ---- Canvas Drawing Binding ----
	//
	
	canvasEl.addEventListener("touchstart", canvas.onPointerDown);
	canvasEl.addEventListener("mousedown", canvas.onPointerDown);
	
	//
	// ---- Zoom Stuff ----
	//
	
	canvas.repaintBoxShadow = function () {
	
		// Blink misrenders the canvas edge as blurry after any zoom.
		// Blink also sometimes mistakenly shows scroll bars on the outer bg.
		// This is a Blink bug, the internal dim is less than the outer bg.
		// Removing the box-shadow class, forcing render, then
		// adding it back again fixes it. Yuck!
		canvasEl.classList.remove("main-canvas--box-shadow");
		w.getComputedStyle(canvasEl); // Force render. Yuck.
		w.setTimeout(function () {
			canvasEl.classList.add("main-canvas--box-shadow");
		}, 90); // Waiting less than 90ms doesn't seem to work. WTF.
	};
	
	canvas.handleIncrementalZoom = function (e, keybindingZoomDirection) {
	
		// Zoom on touch is handled via pinch. We want to duck synthetic click events.
		// For mobile/touch, get out, and don't prevent default.
		if (state.toolbox.tool !== "zoom-in" && state.toolbox.tool !== "zoom-out" && !keybindingZoomDirection || state.toolbox.override || !browser.isBig) {
			return;
		}
	
		var currentScale = state.canvas.scale;
		var newScale = currentScale; // Default to same. In case of some mistake below.
	
		// Snapshot of previous pre-zoom state for passing to scroll calculator.
		var prevScroll = {
			overflowed: state.canvas.overflowsInnerView,
			x: state.innerView.scroll.x,
			y: state.innerView.scroll.y,
			scale: currentScale
		};
	
		var zoomArray = [0.333, // 0 (index number)
		0.5, // 1
		0.667, // 2
		1, // 3 (= 100% scale)
		2, // 4
		3, // 5
		4, // 6
		5, // 7
		6, // 8
		7, // 9
		8, // 10
		12, // 11
		16, // 12
		32, // 13
		64 // 14
		];
	
		var direction = state.toolbox.tool; // E.g. "zoom-in" or "zoom-out"
	
		// Keyboard shortcut overrides toolbox
		if (keybindingZoomDirection) {
			direction = keybindingZoomDirection; // Again, "zoom-in" or "zoom-out"
		}
	
		if (direction === "zoom-in") {
			for (var _i4 = 0; _i4 < 15; _i4 += 1) {
				if (zoomArray[_i4] > currentScale) {
					newScale = zoomArray[_i4];
					break;
				}
			}
		} else {
			for (var _i5 = 14; _i5 > -1; _i5 -= 1) {
				if (zoomArray[_i5] < currentScale) {
					newScale = zoomArray[_i5];
					break;
				}
			}
		}
	
		// If no change, perhaps we're at one of the ends of the zoom scale, get out.
		if (newScale === currentScale) {
			return;
		}
	
		// Set scale since it has changed.
		canvasEl.setAttribute("style", "transform: scale(" + newScale + ")");
		state.canvas.scale = newScale;
		if (browser.isBlink) {
			canvas.repaintBoxShadow();
		}
	
		// Toggles classes and styles on innerView, and will remove scroll if canvas is contained.
		canvas.evaluateOverflow(newScale);
	
		if (state.canvas.overflowsInnerView) {
			canvas.setScrollPositionBasedOnZoomEvent(e, prevScroll, keybindingZoomDirection);
		}
	};
	
	canvas.evaluateOverflow = function (newScale) {
		var canvasWidth = state.canvas.domDim.x;
		var canvasHeight = state.canvas.domDim.y;
		var theScale = state.canvas.scale;
		var newOverflow = false;
		var newInnerViewWidth = void 0,
		    newInnerViewHeight = void 0;
		var removeNavOutlineDimensions = false;
	
		// For example, newScale is undefined when called on resize.
		// Also note newScale equals 0 when zoomed all the way out.
		if (newScale !== undefined) {
			theScale = newScale;
		}
	
		// No overflow on update.
		if (canvasWidth * theScale < state.innerView.visibleWidth && canvasHeight * theScale < state.innerView.visibleHeight) {
	
			if (state.canvas.overflowsInnerView) {
	
				// Unsure on this. TO DO: review state etc.
				state.innerView.width = innerView.visibleWidth;
				state.innerView.height = innerView.visibleHeight;
				state.innerView.scroll.x = undefined;
				state.innerView.scroll.y = undefined;
	
				innerViewEl.classList.remove("inner-background--canvas-overflows");
	
				// Effectively reverts height and width back to 100% values in stylesheet.
				innerViewEl.style.width = "";
				innerViewEl.style.height = "";
				removeNavOutlineDimensions = true;
			}
	
			// Else one or more of the dims overflows the innerView,
			// so switch into overflow state if we aren't already,
			// and set dims using explicit numeric CSS values.
		} else {
			newOverflow = true;
	
			// Base innerView dims on canvas.
			// Note however that height is constrained to min-height: 100% in stylesheet,
			// in the stylesheet, otherwise vertical centering would break.
			newInnerViewWidth = canvasWidth * theScale + state.canvas.zoomPadding * 2;
			newInnerViewHeight = canvasHeight * theScale + state.canvas.zoomPadding * 2;
	
			// But don't let them ever be less than 100% or it breaks centering
			state.innerView.width = newInnerViewWidth;
			state.innerView.height = newInnerViewHeight;
			innerViewEl.style.width = newInnerViewWidth + "px";
			innerViewEl.style.height = newInnerViewHeight + "px";
	
			// Note that in this case scroll positions will still need to be set.
	
			if (!state.canvas.overflowsInnerView) {
				innerViewEl.classList.add("inner-background--canvas-overflows");
			}
		}
	
		state.canvas.overflowsInnerView = newOverflow;
		updateNavOutline(removeNavOutlineDimensions);
	};
	
	// Set scroll position on any overflow.
	// Always called within a conditional. Assume state.canvas.overflowsInnerView true.
	canvas.setScrollPositionBasedOnZoomEvent = function (e, prevScroll, keybindingZoomDirection, pinchCenterX, pinchCenterY, pinchPanX, pinchPanY) {
		var cWidth = state.canvas.domDim.x;
		var cHeight = state.canvas.domDim.y;
		var zoomPadding = state.canvas.zoomPadding;
		var prevScale = prevScroll.scale;
		var newScale = state.canvas.scale;
		pinchPanX = pinchPanX || 0;
		pinchPanY = pinchPanY || 0;
	
		// Event pageX/Y will exist for for mouse clicks.
		// (Keyboard-shortcut-initiated zooms have a synthetic pageX/Y.)
		// e will be null for pinch zooms.
		var zoomCenterX = e && e.pageX || pinchCenterX;
		var zoomCenterY = e && e.pageY || pinchCenterY;
	
		var canvasTransX = void 0,
		    canvasTransY = void 0,
		    curCenteredFromLeft = void 0,
		    curCenteredFromTop = void 0,
		    canvasRawX = void 0,
		    canvasRawY = void 0,
		    newScrollX = void 0,
		    newScrollY = void 0;
	
		if (prevScroll.overflowed) {
			canvasTransX = zoomCenterX + prevScroll.x - zoomPadding;
			canvasTransY = zoomCenterY + prevScroll.y - zoomPadding;
	
			// Previously no scroll bars
		} else {
			curCenteredFromLeft = (state.innerView.visibleWidth - cWidth * prevScale) / 2;
			curCenteredFromTop = (state.innerView.visibleHeight - cHeight * prevScale) / 2;
	
			canvasTransX = zoomCenterX - curCenteredFromLeft;
			canvasTransY = zoomCenterY - curCenteredFromTop;
		}
	
		canvasRawX = canvasTransX / prevScale;
		canvasRawY = canvasTransY / prevScale;
	
		// If the user is scroll centered, and zoom-clicks in the center of the canvas,
		// the new scroll should scale up in proportion to the
		// (new innerView / old Inner view)
	
		newScrollX = zoomPadding + canvasRawX * newScale - zoomCenterX;
		newScrollY = zoomPadding + canvasRawY * newScale - zoomCenterY;
	
		// Adjust for possible pinch panning. (Moving the pinch center during the pinch.)
		newScrollX -= pinchPanX;
		newScrollY -= pinchPanY;
	
		innerView.setScrollPosition(newScrollX, newScrollY);
	};
	
	canvas.handleFitZoom = function () {
		var canvasWidth = state.canvas.domDim.x;
		var canvasHeight = state.canvas.domDim.y;
		var innerViewVisWidth = state.innerView.visibleWidth;
		var innerViewVisHeight = state.innerView.visibleHeight;
		var newScale = void 0;
		var innerViewVisibleProportion = innerViewVisWidth / innerViewVisHeight;
		var canvasProportion = canvasWidth / canvasHeight;
	
		if (innerViewVisibleProportion >= canvasProportion) {
	
			// The wide Inner View case, fit height
			newScale = innerViewVisHeight / canvasHeight;
		} else {
			newScale = innerViewVisWidth / canvasWidth;
		}
	
		// Remove any overflow styles
		if (state.canvas.overflowsInnerView) {
			innerViewEl.classList.remove("inner-background--canvas-overflows");
	
			// Remove explicit width and height
			innerViewEl.removeAttribute("style");
		}
	
		// Fit should always center the canvas, removing any CSS translate()
		canvasEl.setAttribute("style", "transform: scale(" + newScale + ")");
	
		state.canvas.overflowsInnerView = false;
	
		// Remove scroll
		state.innerView.scroll.x = undefined;
		state.innerView.scroll.y = undefined;
	
		// Reset navigation outline
		navOutlineEl.removeAttribute("style");
		state.nav.outline.posX = 0;
		state.nav.outline.posY = 0;
		state.nav.outline.percentageX = 1;
		state.nav.outline.percentageY = 1;
	
		state.canvas.scale = newScale;
		if (browser.isBlink) {
			canvas.repaintBoxShadow();
		}
	};
	
	// Don't bother binding a listener for touchstart because pinch handles
	// all zoom in the mobile/tablet interface.
	innerViewEl.addEventListener("click", canvas.handleIncrementalZoom);
	
	//*******************************************
	//*******
	//******* ---- Pinch/Zoom on Touch ----
	//*******
	//*******************************************
	
	// Create a manager for the inner view.
	var hammerInnerV = new Hammer.Manager(innerViewEl, {
		touchAction: "pan-x pan-y" // Allow default native panning behaviors for single touches.
	});
	
	// Create a recognizer, and add that recognizer to the manager.
	hammerInnerV.add(new Hammer.Pinch());
	
	// Holds snapshot of pre-pinch state.
	var initPinch = Object.create(null);
	
	hammerInnerV.on("pinchstart", function (e) {
		e.preventDefault(); // Always on pinchstart.
		if (state.toolbox.tool !== "zoom-in") {
			return;
		}
	
		initPinch.overflowed = state.canvas.overflowsInnerView;
		initPinch.x = state.innerView.scroll.x;
		initPinch.y = state.innerView.scroll.y;
		initPinch.scale = state.canvas.scale;
		initPinch.center = e.center;
	
		// No CSS scale transition timing.
		canvasEl.classList.remove("main-canvas--transition-scale");
	});
	
	hammerInnerV.on("pinch", function (e) {
		e.preventDefault(); // Always on pinch.
	
		if (state.toolbox.tool !== "zoom-in") {
			return;
		}
	
		var newScale = initPinch.scale * e.scale;
		canvasEl.style.transform = "scale(" + newScale + ")";
		state.canvas.scale = newScale;
	
		var initPinchCenter = initPinch.center;
		var newPinchCenter = e.center;
	
		// Reevaluate overflow continuously during the pinch.
		canvas.evaluateOverflow(newScale);
	
		// When in overflow mode, scroll should adjust so that the center of the pinch on the canvas
		// tracks to the same screen position. Also pinch centers can "pan" during pinch.
		var pinchPanX = newPinchCenter.x - initPinchCenter.x;
		var pinchPanY = newPinchCenter.y - initPinchCenter.y;
	
		canvas.setScrollPositionBasedOnZoomEvent(null, initPinch, null, initPinchCenter.x, initPinchCenter.y, pinchPanX, pinchPanY);
	});
	
	hammerInnerV.on("pinchend", function (e) {
		e.preventDefault(); // Always on pinchend.
	
		if (state.toolbox.tool !== "zoom-in") {
			return;
		}
	
		if (browser.isBlink) {
			canvas.repaintBoxShadow();
		}
	});
	
	//*******************************************
	//*******
	//******* ---- Toolbox ----
	//*******
	//*******************************************
	
	// Arguments are button event, string is "brush" or "eraser or "hand" etc.
	var setToolboxTool = function setToolboxTool(e, newToolNameStr) {
		newToolNameStr = newToolNameStr || this.getAttribute("data-tool-button");
	
		if (newToolNameStr === state.toolbox.tool) {
			return;
		} // Get out
		for (var _i6 = 0; _i6 < 5; _i6 += 1) {
			toolboxButtonEls[_i6].classList.remove("panel__button--selected");
		}
		var selectedButton = doc.querySelector("[data-tool-button=" + newToolNameStr);
		selectedButton.classList.add("panel__button--selected");
	
		// Handle CSS cursors.
		innerViewEl.classList.remove("brush-tool", "eraser-tool", "hand-tool", "zoom-in-tool", "zoom-out-tool");
		innerViewEl.classList.add(newToolNameStr + "-tool");
	
		state.toolbox.tool = newToolNameStr;
	};
	
	Gator(toolboxEl).on(["touchstart", "mousedown"], ".toolbox__button", setToolboxTool);
	
	//*******************************************
	//*******
	//******* ---- Navigator ----
	//*******
	//*******************************************
	
	// Called by innerView.onUserScroll and canvas.evaluateOverflow
	var updateNavOutline = function updateNavOutline(removeNavOutlineDimensions) {
		if (!browser.isBig) {
			return;
		}
	
		// Called from evaluateOverflow if there's been a change from
		// overflow to no overflow.
		if (removeNavOutlineDimensions) {
			navOutlineEl.removeAttribute("style");
			return;
		}
	
		// This early return must stay in place here. Don't refactor.
		if (!state.canvas.overflowsInnerView) {
			return;
		}
	
		// Default if roughly centered, doesn't yet account for scroll position.
		var mainCanvasVisibleX = state.innerView.visibleWidth;
		var mainCanvasVisibleY = state.innerView.visibleHeight;
		var padding = state.canvas.zoomPadding;
		var scale = state.canvas.scale;
		var percentageVisibleX = void 0,
		    percentageVisibleY = void 0,
		    ratioBetweenCanvases = void 0,
		    outlinePosX = void 0,
		    outlinePosY = void 0;
	
		// If scrolled to left edge
		if (state.innerView.scroll.x < padding) {
			mainCanvasVisibleX -= padding - state.innerView.scroll.x;
	
			// If scrolled to right edge
		} else if (state.innerView.scroll.x > state.innerView.width - state.innerView.visibleWidth - padding) {
			mainCanvasVisibleX -= state.innerView.scroll.x - (state.innerView.width - state.innerView.visibleWidth - padding);
		}
	
		// If scrolled to top edge
		if (state.innerView.scroll.y < padding) {
			mainCanvasVisibleY -= padding - state.innerView.scroll.y;
	
			// If scrolled to bottom edge
		} else if (state.innerView.scroll.y > state.innerView.height - state.innerView.visibleHeight - padding) {
			mainCanvasVisibleY -= state.innerView.scroll.y - (state.innerView.height - state.innerView.visibleHeight - padding);
		}
	
		percentageVisibleX = mainCanvasVisibleX / (state.canvas.domDim.x * scale);
		percentageVisibleY = mainCanvasVisibleY / (state.canvas.domDim.y * scale);
	
		// If width or height have changed then set them on the element
		if (percentageVisibleX !== state.nav.outline.percentageX) {
			state.nav.outline.percentageX = percentageVisibleX;
			navOutlineEl.style.width = percentageVisibleX * 100 + "%";
		}
		if (percentageVisibleY !== state.nav.outline.percentageY) {
			state.nav.outline.percentageY = percentageVisibleY;
			navOutlineEl.style.height = percentageVisibleY * 100 + "%";
		}
	
		// Use the larger of the two dimensions to calculate the ratio,
		// in order to minimize ugly rounding errors.
		if (state.nav.canvas.width > state.nav.canvas.height) {
			ratioBetweenCanvases = state.nav.canvas.width / (state.canvas.domDim.x * scale);
		} else {
			ratioBetweenCanvases = state.nav.canvas.height / (state.canvas.domDim.y * scale);
		}
	
		outlinePosX = (state.innerView.scroll.x - padding) * ratioBetweenCanvases;
		outlinePosY = (state.innerView.scroll.y - padding) * ratioBetweenCanvases;
	
		// Clamp outline to 0,0 (don't allow negative).
		outlinePosX = Math.max(0, outlinePosX);
		outlinePosY = Math.max(0, outlinePosY);
	
		state.nav.outline.posX = outlinePosX;
		state.nav.outline.posy = outlinePosY;
		navOutlineEl.style.transform = "translate(" + outlinePosX + "px," + outlinePosY + "px)";
	};
	
	//*******************************************
	//*******
	//******* ---- Info ----
	//*******
	//*******************************************
	
	var updateCursorCoordinates = function updateCursorCoordinates(e) {
	
		// IE reports non-integer values for offset. Round down.
		// Consider removing floor() if never supporting IE.
		infoCursorXEl.textContent = Math.floor(e.offsetX);
		infoCursorYEl.textContent = Math.floor(e.offsetY);
	};
	
	var handleCoordinatesEnter = function handleCoordinatesEnter(e) {
		updateCursorCoordinates(e);
		canvasEl.addEventListener("mousemove", updateCursorCoordinates);
		canvasEl.addEventListener("mouseleave", handleCoordinatesLeave);
	};
	
	var handleCoordinatesLeave = function handleCoordinatesLeave(e) {
		infoCursorXEl.textContent = "";
		infoCursorYEl.textContent = "";
		canvasEl.removeEventListener("mousemove", updateCursorCoordinates);
		canvasEl.removeEventListener("mouseleave", handleCoordinatesLeave);
	};
	
	//*******************************************
	//*******
	//******* ---- Player ----
	//*******
	//*******************************************
	
	var player = Object.create(null);
	
	player.setSpeed = function (event, num) {
	
		// Arguments will include an Event in case it's being emitted from the input
		// slider, but can also be set directly below based on read-in values.
		var val = event && event.target ? event.target.value : num;
		val = Math.max(0, Math.min(6, val)); // Must be between 0 and 6 inclusive.
		state.player.delay = [1600, 750, 200, 100, 50, 25, "none"][val]; // Durations in ms.
	
		if (!event) {
			playerSpeedInputEl.value = val;
		}
	
		// The data-* attribute creates a CSS hook for the position styling of the SVG thumb.
		playerSpeedInputEl.setAttribute("data-player-speed-input", val);
	};
	
	// Allow the next few often-called fns to live in the outermost scope, to reduce object lookups.
	
	// A 3x3 bitmap has 2^9 = 512 possible states.
	// 000000001 = 1
	// 000000010 = 2
	// 000000011 = 3
	// 000000100 = 4
	// 000000101 = 5
	// 000000110 = 6
	// 000000111 = 7
	// 000001000 = 8
	// 000001001 = 9
	// 000001010 = 10
	// 000001011 = 11
	// 000001100 = 12
	// 000001101 = 13
	// 000001110 = 14
	// 000001111 = 15
	// 111000000 = 448 etc.
	
	// Pre-build and store a lookup array mapping all the possibilities.
	// Stores the number of active cells in the nine cell neighborhood,
	// including the center cell.
	var bitmapLookupArr = new Uint8Array(512);
	for (var _i7 = 0; _i7 < 512; _i7 += 1) {
		bitmapLookupArr[_i7] = _i7.toString(2).split("1").length - 1;
	}
	
	var bitmap = 0;
	
	var getTileFromFlatArray = function getTileFromFlatArray(x, y, cWidth, dataArray) {
		return dataArray[y * cWidth + x];
	};
	
	// Listlife reference at: http://dotat.at/prog/life/life.html
	// Local cell neighborhood as binary map:
	//  _______________________________________________________
	//  |                  |                 |                 |
	//  |  001000000 = 64  |  000001000 = 8  |  000000001 = 1  |
	//  |__________________|_________________|_________________|
	//  |                  |                 |                 |
	//  |  010000000 = 128 |  000010000 = 16 |  000000010 = 2  |
	//  |__________________|_________________|_________________|
	//  |                  |                 |                 |
	//  |  100000000 = 256 |  000100000 = 32 |  000000100 = 4  |
	//  |__________________|_________________|_________________|
	
	var countNonToroidal = function countNonToroidal(x, y, cWidth, cHeight, dataArray) {
	
		var ret = 0;
		var leftEdge = x === 0;
		var rightEdge = x === cWidth - 1;
		var topEdge = y === 0;
		var bottomEdge = y === cHeight - 1;
		var centerActive = false;
		var neighborhoodCount = void 0;
	
		if (leftEdge) {
			bitmap = 0;
		} else {
	
			// Move binary representation three cells to left, adding zeroes from the right.
			// Using the shift allows 3 array lookups for non-edge cells, instead of 9.
			bitmap = bitmap << 3;
			bitmap = bitmap & 511; // 511 = "111111111". Set all but the 9 right most digits equal to 0.
			centerActive = (bitmap & 16) === 16;
		}
	
		// Always add cells in column to the right, for all cases.
	
		// Top right cell.
		if (!rightEdge && !topEdge && getTileFromFlatArray(x + 1, y - 1, cWidth, dataArray)) {
			bitmap = bitmap | 1;
		}
	
		// Right cell.
		if (!rightEdge && getTileFromFlatArray(x + 1, y, cWidth, dataArray)) {
			bitmap = bitmap | 2;
		}
	
		// Bottom right cell.
		if (!rightEdge && !bottomEdge && getTileFromFlatArray(x + 1, y + 1, cWidth, dataArray)) {
			bitmap = bitmap | 4;
		}
	
		if (leftEdge) {
	
			// Top cell.
			if (!topEdge && getTileFromFlatArray(x, y - 1, cWidth, dataArray)) {
				bitmap = bitmap | 8;
			}
	
			// Center cell.
			if (getTileFromFlatArray(x, y, cWidth, dataArray)) {
				bitmap = bitmap | 16;
				centerActive = true;
			}
	
			// Bottom cell.
			if (!bottomEdge && getTileFromFlatArray(x, y + 1, cWidth, dataArray)) {
				bitmap = bitmap | 32;
			}
		}
	
		neighborhoodCount = bitmapLookupArr[bitmap];
		if (neighborhoodCount === 3 || centerActive && neighborhoodCount === 4) {
			ret = 1;
		}
		return ret;
	};
	
	// Substantially similar logic, but putting in a separate function avoids an extra "if"
	// statement (or wrapper function) in the typical render loop.
	var countToroidal = function countToroidal(x, y, cWidth, cHeight, dataArray) {
	
		var ret = 0;
		var leftEdge = x === 0;
		var rightEdge = x === cWidth - 1;
		var topEdge = y === 0;
		var bottomEdge = y === cHeight - 1;
		var centerActive = false;
		var neighborhoodCount = void 0;
	
		if (leftEdge) {
			bitmap = 0;
		} else {
	
			// Move binary representation three cells to left, adding zeroes from the right.
			// Using the shift allows 3 array lookups for non-edge cells, instead of 9.
			bitmap = bitmap << 3;
			bitmap = bitmap & 511; // 511 = "111111111". Set all but the 9 right most digits equal to 0.
			centerActive = (bitmap & 16) === 16;
		}
	
		// Account for wrapping behavior.
		var left = x - 1;
		var right = x + 1;
		var top = y - 1;
		var bottom = y + 1;
	
		if (leftEdge) {
			left = cWidth - 1; // Wrap left edge over to the right.
		} else if (rightEdge) {
			right = 0; // Wrap right edge over to the left.
		}
		if (topEdge) {
			top = cHeight - 1; // Wrap above top over to the bottom.
		} else if (bottomEdge) {
			bottom = 0; // Wrap below bottom over to the top.
		}
	
		// Always add cells in column to the right, for all cases, even on the edges.
	
		// Top right cell.
		if (getTileFromFlatArray(right, top, cWidth, dataArray)) {
			bitmap = bitmap | 1;
		}
	
		// Right cell.
		if (getTileFromFlatArray(right, y, cWidth, dataArray)) {
			bitmap = bitmap | 2;
		}
	
		// Bottom right cell.
		if (getTileFromFlatArray(right, bottom, cWidth, dataArray)) {
			bitmap = bitmap | 4;
		}
	
		// Add center and left columns.
		if (leftEdge) {
	
			// Top cell.
			if (getTileFromFlatArray(x, top, cWidth, dataArray)) {
				bitmap = bitmap | 8;
			}
	
			// Center cell.
			if (getTileFromFlatArray(x, y, cWidth, dataArray)) {
				bitmap = bitmap | 16;
				centerActive = true;
			}
	
			// Bottom cell.
			if (getTileFromFlatArray(x, bottom, cWidth, dataArray)) {
				bitmap = bitmap | 32;
			}
	
			// Top left cell.
			if (getTileFromFlatArray(left, top, cWidth, dataArray)) {
				bitmap = bitmap | 64;
			}
	
			// Left cell.
			if (getTileFromFlatArray(left, y, cWidth, dataArray)) {
				bitmap = bitmap | 128;
			}
	
			// Bottom left cell.
			if (getTileFromFlatArray(left, bottom, cWidth, dataArray)) {
				bitmap = bitmap | 256;
			}
		}
	
		neighborhoodCount = bitmapLookupArr[bitmap];
		if (neighborhoodCount === 3 || centerActive && neighborhoodCount === 4) {
			ret = 1;
		}
		return ret;
	};
	
	var countLiveNeighbors = countNonToroidal; // Initial setting.
	
	player.setToroidal = function (e) {
		if (e.target.checked) {
			state.player.toroidal = true;
			countLiveNeighbors = countToroidal;
		} else {
			state.player.toroidal = false;
			countLiveNeighbors = countNonToroidal;
		}
	};
	
	// Perf Testing.
	// let renderNextGenPerfCounter = 0;
	// let renderNextGenDuration = 0;
	
	player.renderNextGeneration = function () {
	
		// Performance checking Main paint start.
		// let renderNextGenStart = performance.now();
	
		var currentValue = void 0,
		    neighborCount = void 0;
		var cWidth = state.canvas.domDim.x;
		var cHeight = state.canvas.domDim.y;
		var dataArray = state.canvas.dataArray;
		var newDataArray = new Int8Array(cWidth * cHeight); // All initially zero.
		var pixels = state.canvas.pixelBuffer;
	
		// Performance checking math start.
		// let arrayMathStart = performance.now();
	
		for (var _i8 = 0; _i8 < cHeight; _i8 += 1) {
			// Outer loop is rows.
			for (var j = 0; j < cWidth; j += 1) {
				// Inner loop is columns.
	
				// A 1 (live) or 0 (dead)
				var value = countLiveNeighbors(j, _i8, cWidth, cHeight, dataArray);
				newDataArray[_i8 * cWidth + j] = value;
	
				// Repeat the logic from canvas.paintBothCanvasesBitwise here to
				// avoid an separate loop through all pixels.
				// Convert 1 (live) to 0. Convert 0 (dead) to 255.
				var colorValue = 255 - value * 255;
	
				pixels[_i8 * cWidth + j] = 255 << 24 | /* alpha always opaque*/
				colorValue << 16 | /* blue */
				colorValue << 8 | /* green */
				colorValue; /* red */
			}
		}
	
		canvasCtx.putImageData(state.canvas.imageData, 0, 0);
		navCanvasCtx.putImageData(state.canvas.imageData, 0, 0);
	
		// Performance checking Main paint end.
		// let renderNextGenEnd = performance.now();
		// renderNextGenDuration += renderNextGenEnd - renderNextGenStart;
		// if ( renderNextGenPerfCounter  === 59 ) {
		// 	console.log( "Avg renderNextGen: " + ( renderNextGenDuration / 60 ) + " ms." );
		// 	renderNextGenPerfCounter = 0;
		// 	renderNextGenDuration = 0;
		// }
		// renderNextGenPerfCounter += 1;
	
		state.canvas.dataArray = newDataArray; // Swap.
	
		// Increment the generation counter
		playerCounterEl.textContent = state.player.generation = state.player.generation += 1;
	
		// If playing, then loop.
		if (state.player.isPlaying) {
			if (state.player.delay === "none") {
				nextFrameID = requestAnimationFrame(player.renderNextGeneration);
			} else {
				nextFrameID = w.setTimeout(function () {
					requestAnimationFrame(player.renderNextGeneration);
				}, state.player.delay);
			}
		}
	};
	
	player.pause = function () {
	
		// Cancel any scheduled stepAll call so that resets while playing don't step forward
		// to generation 1.
		if (state.player.isPlaying) {
			if (state.player.delay === "none") {
				cancelAnimationFrame(nextFrameID);
			} else {
				w.clearTimeout(nextFrameID);
			}
		}
		state.player.isPlaying = false;
		playerPlayButtonEl.classList.remove("player__play-button--is-playing");
	};
	
	player.onPlayerClearButton = function (e) {
		player.onResetGenerationsCounter(e);
		voidCurrentSelectedPatternLink();
		canvas.clearDataArray();
		canvas.clearMainAndNavCanvases();
	};
	
	player.onResetGenerationsCounter = function (e) {
		if (e && e.type === "touchstart") {
			e.preventDefault();
		}
		player.pause();
		playerCounterEl.textContent = "0";
		state.player.generation = 0;
	};
	
	player.onStepButton = function (e) {
		if (e && e.type === "touchstart") {
			e.preventDefault();
		}
		if (state.player.isPlaying) {
			player.pause();
		}
		voidCurrentSelectedPatternLink();
		clearAnyHash();
		player.renderNextGeneration();
	};
	
	player.play = function () {
		state.player.isPlaying = true;
		playerPlayButtonEl.classList.add("player__play-button--is-playing");
		voidCurrentSelectedPatternLink();
		clearAnyHash();
		player.renderNextGeneration();
	};
	
	player.onPlayStopButton = function (e) {
		if (e && e.type === "touchstart") {
			e.preventDefault();
		}
		if (state.player.isPlaying) {
			player.pause();
		} else {
			player.play();
		}
	};
	
	playerToroidalInputEl.addEventListener("change", player.setToroidal);
	
	playerSpeedInputEl.addEventListener("input", player.setSpeed);
	
	playerClearButtonEl.addEventListener("touchstart", player.onPlayerClearButton);
	playerClearButtonEl.addEventListener("mousedown", player.onPlayerClearButton);
	
	playerResetButtonEl.addEventListener("touchstart", player.onResetGenerationsCounter);
	playerResetButtonEl.addEventListener("mousedown", player.onResetGenerationsCounter);
	
	playerPlayButtonEl.addEventListener("touchstart", player.onPlayStopButton);
	playerPlayButtonEl.addEventListener("mousedown", player.onPlayStopButton);
	
	playerStepButtonEl.addEventListener("touchstart", player.onStepButton);
	playerStepButtonEl.addEventListener("mousedown", player.onStepButton);
	
	//*******************************************
	//*******
	//******* ---- Patterns ----
	//*******
	//*******************************************
	
	var voidCurrentSelectedPatternLink = function voidCurrentSelectedPatternLink() {
		var currentSelectedLink = state.patterns.currentSelectedLink;
		if (currentSelectedLink) {
			currentSelectedLink.parentNode.classList.remove("pat--selected", "pat--loading");
			state.patterns.currentSelectedLink = null;
		}
	};
	
	// Patterns need room to breathe.
	// Canvas of an imported pattern that doesn't have a minCanvasX or minCanvasY properties
	// should be at least three times the core pattern dimensions on that side, with a
	// minimum value based on viewport media query.
	// (This helps keep small patterns fast on mobile.)
	// If the pattern includes minimum dimensions and/or offset values for positioning,
	// use those.
	var addPatternMargins = function addPatternMargins(patPixArray, patWidth, patHeight, minCanvasX, minCanvasY, offsetX, offsetY) {
	
		var minMargin = w.browser.isBig ? 200 : 80;
		var outputWidth = minCanvasX || Math.max(patWidth * 3, minMargin);
		var outputHeight = minCanvasY || Math.max(patHeight * 3, minMargin);
		var newPixArray = new Int8Array(outputWidth * outputHeight); // All zeros initially
		var len = patWidth * patHeight;
		var curX = void 0,
		    curY = void 0;
	
		// Use any pixel offset if supplied, otherwise calculate
		// Validate offset values.
		if (!ut.isNonNegativeInteger(offsetX)) {
			offsetX = Math.floor((outputWidth - patWidth) / 2); // Default to centered
		}
		if (!ut.isNonNegativeInteger(offsetY)) {
			offsetY = Math.floor((outputHeight - patHeight) / 2);
		}
	
		for (var _i9 = 0; _i9 < len; _i9 += 1) {
			curX = _i9 % patWidth;
			curY = Math.floor(_i9 / patWidth);
			newPixArray[(curY + offsetY) * outputWidth + curX + offsetX] = patPixArray[_i9];
		}
	
		return {
			dataArray: newPixArray,
			width: outputWidth,
			height: outputHeight
		};
	};
	
	var redrawCanvasFromDataArray = function redrawCanvasFromDataArray(dataArray, width, height) {
	
		// Don't reset generations counter here, because might be canvas resizing.
		// Don't transition-zoom.
		canvasEl.classList.remove("main-canvas--transition-scale");
		canvas.setCanvasDim(width, height);
		state.canvas.dataArray = dataArray;
		canvas.paintBothCanvasesBitwise();
	
		w.requestAnimationFrame(function () {
			canvas.handleFitZoom();
			canvasEl.classList.add("main-canvas--transition-scale");
		});
	};
	
	/**
	* @param {object} d - The JSON
	* @param {Boolean} addMargin - Whether or not additional margins should be considered.
	*/
	var loadPatternJSONToCanvas = function loadPatternJSONToCanvas(d, addMargin) {
		var patternStr = d.pattern;
		var width = d.width;
		var height = d.height;
		var minCanvasX = d.minCanvasX;
		var minCanvasY = d.minCanvasY;
		var offsetX = d.offsetX;
		var offsetY = d.offsetY;
		var isToroidal = !!d.toroidal;
	
		if (!patternStr) {
			console.log("Pattern file parse error");
		}
	
		var pixelArray = parseRLEPixelString(patternStr, width, height);
		var marginAddedObj = void 0;
	
		// Add margins for included JSON patterns.
		if (addMargin) {
			marginAddedObj = addPatternMargins(pixelArray, width, height, minCanvasX, minCanvasY, offsetX, offsetY);
			pixelArray = marginAddedObj.dataArray;
			width = marginAddedObj.width;
			height = marginAddedObj.height;
		}
	
		redrawCanvasFromDataArray(pixelArray, width, height);
		player.onResetGenerationsCounter();
	
		playerToroidalInputEl.checked = isToroidal; // Set on DOM element. Doesn't fire a change event.
		state.player.toroidal = isToroidal;
		countLiveNeighbors = isToroidal ? countToroidal : countNonToroidal;
	};
	
	var onPatternLinkClick = function onPatternLinkClick(e) {
		e.preventDefault(); // Always for both touch and mouse.
	
		// Hide any mobile UI.
		// patternsPanelEl.classList.remove( "patterns--mobile-show" );
		// patternsButtonMobileEl.classList.remove( "panel__button--selected" );
	
		openCloseMobileFlyouts(); // Don't need to pass e. Calling w/o arguments closes everything.
	
		var patternListItem = this.parentNode;
	
		player.pause(); // Stop any current animation.
		canvas.clearMainAndNavCanvases();
	
		voidCurrentSelectedPatternLink();
	
		// Remove loading class from all other pattern list items.
		for (var _i10 = 0; _i10 < patternsListItemEls.length; _i10 += 1) {
			patternsListItemEls[_i10].classList.remove("pat--loading");
		}
		patternListItem.classList.add("pat--selected", "pat--loading");
	
		// Store for comparison when XHR returns, and also for removing classes.
		state.patterns.currentSelectedLink = this;
	
		fetch(this.href).then(function (response) {
	
			// Unlike jQuery.AJAX(), 404 errors do not reject in fetch.
			// Must check for these manually.
			if (!response.ok) {
				var error = new Error(response.statusText);
				error.response = response;
				throw error;
			} else {
				return response;
			}
		}).then(function (response) {
	
			// Patterns may return from the network out of the order clicked on.
			if (response.url !== state.patterns.currentSelectedLink.href) {
				return Promise.reject("Pattern loaded was not the most recently clicked");
			}
	
			// Get relative path from absolute and drop the extension.
			// Sanity check as there are probably some typos in markup.
			var fileName = response.url.split("/").pop();
			if (fileName.slice(-5) === ".json") {
				fileName = fileName.slice(0, -5);
				w.history.replaceState(undefined, undefined, "#" + fileName);
				return response.json();
			} else {
				return Promise.reject("Response didn't have a '.json' extension");
			}
		}).then(function (json) {
	
			loadPatternJSONToCanvas(json, true);
		}).catch(function (error) {
	
			// Catch and log any error that has happened along the way.
			console.log("error:", error);
		}).then(function () {
	
			// Always remove the "loading" class when the promise is settled
			// and no longer pending, in all cases.
			patternListItem.classList.remove("pat--loading");
		});
	};
	
	// Attach delegated event handler for patterns.
	// Don't listen for touchstart because the link list needs to be scrollable.
	Gator(patternsWrapperEl).on("click", ".pat__link", onPatternLinkClick);
	
	//*******************************************
	//*******
	//******* ---- All Modals ----
	//*******
	//*******************************************
	
	Modal.modalSetOpenState = function (bool) {
		state.isModalOpen = bool;
	};
	
	//*******************************************
	//*******
	//******* ---- Canvas Size Modal ----
	//*******
	//*******************************************
	
	modalCanvasSize.modalBeforeOpen = function () {
		this.currentCanvasWidth = state.canvas.domDim.x;
		this.currentCanvasHeight = state.canvas.domDim.y;
	};
	modalCanvasSize.modalSubmit = function () {
		canvas.handleResize(this.newWidth, this.newHeight, this.resizeIconPositionX, this.resizeIconPositionY);
	};
	modalCanvasSize.init(infoCanvasSizeButtonEl);
	
	//*******************************************
	//*******
	//******* ---- Pattern Open Modal ----
	//*******
	//*******************************************
	
	modalOpenPattern.modalSubmit = function () {
		var fileExt = this.fileExtension;
		var pat = this.parsedPattern;
	
		// The selected file should already be parsed by the time the user clicks "OK" in modal.
		// (We don't currently check for this asynchronicity.)
		// Don't ever add any margins to patterns loaded externally.
	
		// Text files have RLE string for pattern property.
		if (fileExt === "JSON" || fileExt === "RLE") {
			loadPatternJSONToCanvas(pat, false);
		} else if (fileExt === "BMP") {
	
			// BMP files have data array for pixels property.
			redrawCanvasFromDataArray(pat.pixels, pat.width, pat.height);
		}
	
		voidCurrentSelectedPatternLink();
		clearAnyHash();
		player.onResetGenerationsCounter();
		w.history.replaceState(undefined, undefined, w.location.pathname);
	};
	
	modalOpenPattern.init(patternsOpenButtonEl);
	
	//*******************************************
	//*******
	//******* ---- Pattern Save Modal ----
	//*******
	//*******************************************
	
	modalSavePattern.modalSubmit = function () {
		var fileFormatEl = doc.querySelector("[data-modal-save-file-format]");
		var patternNameEl = doc.querySelector("[data-modal-save-pattern-name]");
		var patternAuthorEl = doc.querySelector("[data-modal-save-pattern-author]");
		var suppliedPatternName = patternNameEl.value;
		var usedPatternName = suppliedPatternName || "my-lifey-pattern";
		var fileType = fileFormatEl.value;
		var outputStr = void 0;
	
		var orderedPatternForJSON = Object.create(null);
		var patternObj = dataArrayToRLE(state.canvas.dataArray, state.canvas.domDim.x, state.canvas.domDim.y);
	
		// Add the properties to the new object in the order they should be printed.
		if (suppliedPatternName) {
			orderedPatternForJSON.name = suppliedPatternName;
		}
		if (patternAuthorEl.value) {
			orderedPatternForJSON.author = patternAuthorEl.value;
		}
		orderedPatternForJSON.width = patternObj.width;
		orderedPatternForJSON.height = patternObj.height;
		orderedPatternForJSON.minCanvasX = patternObj.minCanvasX;
		orderedPatternForJSON.minCanvasY = patternObj.minCanvasY;
		orderedPatternForJSON.offsetX = patternObj.offsetX;
		orderedPatternForJSON.offsetY = patternObj.offsetY;
		orderedPatternForJSON.pattern = patternObj.pattern;
	
		if (fileType === "json") {
			outputStr = JSON.stringify(orderedPatternForJSON, null, "\t");
		} else if (fileType === "rle") {
			outputStr = patToRleFileString(orderedPatternForJSON);
		}
	
		saveTextAsFile(outputStr, usedPatternName + "." + fileType);
	};
	
	modalSavePattern.init(patternsSaveButtonEl);
	
	//*******************************************
	//*******
	//******* ---- Pattern Share Modal ----
	//*******
	//*******************************************
	
	// Runs after innerMarkup has been added. Not really a binding in this case, but can use.
	modalSharePattern.modalInternalBinding = function () {
		var modalSharePatternFitsEl = doc.querySelector(".pattern-fits-in-url");
		var urlDivEl = doc.querySelector("[data-modal-shareable-url]");
		var cWidth = state.canvas.domDim.x;
		var cHeight = state.canvas.domDim.y;
		var baseURL = w.location.href;
		var patRLEObj = dataArrayToRLE(state.canvas.dataArray, cWidth, cHeight);
		var msg = void 0,
		    linkURL = void 0;
	
		// If sharing a pattern from the library, don't use query string data.
		if (state.patterns.currentSelectedLink) {
			linkURL = baseURL;
		} else {
			linkURL = baseURL + "#" + ut.serializeToQueryString(patRLEObj);
		}
	
		if (!linkURL || linkURL.length > 4000) {
			msg = "Sorry, but your pattern is too large to be shared in a URL." + " Please consider saving to a JSON or RLE text file instead." + " You can also right-click directly on the canvas to save it as a PNG.";
			urlDivEl.classList.add("hide-url");
		} else {
			msg = "The following URL is a permanent, shareable link to the current pattern." + " It has been copied to your system clipboard.";
			urlDivEl.innerHTML = linkURL;
			urlDivEl.focus();
			ut.copyTextToClipBoard(linkURL);
		}
	
		modalSharePatternFitsEl.innerHTML = msg;
	};
	
	modalSharePattern.init(patternsShareButtonEl);
	
	//*******************************************
	//*******
	//******* ---- Keyboard Shortcuts ----
	//*******
	//*******************************************
	
	// Keymaster defines shortcuts within a particular "scope" that corresponds to an area of a
	// single page app. Lifey currently has two areas: "main" and "modal". Nearly all general
	// keyboard shortcuts are disabled in the modal view.
	key.setScope("main"); // Keymaster default scope is "all".
	
	// By default, Keymaster doesn't process shortcuts when INPUT, SELECT, or
	// TEXTAREA elements are focused. Loosen this restriction to allow shortcuts
	// to work when INPUT elements are focused.
	key.filter = function (event) {
		var tagName = (event.target || event.srcElement).tagName;
		return !(tagName == "SELECT" || tagName == "TEXTAREA");
	};
	
	// Kill all repeated key events.
	bodyEl.addEventListener("keydown", function (e) {
		if (e.repeat) {
			return false;
		}
	});
	
	// ---- Toolbox Shortcuts ----
	
	// Shift key switches toolbox to the hand tool until the key is released.
	key("shift", "main", function () {
		bodyEl.classList.add("shift-depressed");
		state.toolbox.override = "hand";
	});
	
	// Keyup must be done manually without Keymaster.
	bodyEl.addEventListener("keyup", function (e) {
		if (e.which === 16) {
			bodyEl.classList.remove("shift-depressed");
			state.toolbox.override = null;
		}
	});
	
	key("b", "main", function () {
		setToolboxTool("brush");
	});
	
	key("e", "main", function () {
		setToolboxTool("eraser");
	});
	
	key("h", "main", function () {
		setToolboxTool("hand");
	});
	
	key("z", "main", function () {
		setToolboxTool("zoom-in");
	});
	
	// ---- Zoom Shortcuts ----
	
	// Plus key.
	key(browser.shortkey + "+=", "main", function (e) {
		e.preventDefault();
	
		// Treat keyboard-shortcut-initiated zooms as occurring at center of the visible innerView.
		// Synthesize an event property on them for simplicity.
		e.pageX = state.innerView.visibleWidth / 2;
		e.pageY = state.innerView.visibleHeight / 2;
		canvas.handleIncrementalZoom(e, "zoom-in");
	});
	
	// Minus key.
	key(browser.shortkey + "+-", "main", function (e) {
		e.preventDefault();
		e.pageX = state.innerView.visibleWidth / 2;
		e.pageY = state.innerView.visibleHeight / 2;
		canvas.handleIncrementalZoom(e, "zoom-out");
	});
	
	// Zero key.
	key(browser.shortkey + "+0", "main", function (e) {
		e.preventDefault();
		canvas.handleFitZoom();
	});
	
	// ---- Player Shortcut ----
	
	// As in video software, space bar plays/pauses.
	key("space", "main", function () {
		player.onPlayStopButton();
	});
	
	// ---- Hide Panels Shortcut ----
	
	// Tab key.
	key("tab", "main", function () {
		bodyEl.classList.toggle("hide-panels");
		return false;
	});
	
	// ---- Modal Shortcuts ----
	
	// Treat hitting "enter" as clicking "ok".
	key("enter", "modal", function (e) {
		doc.querySelector("[data-modal-ok]").click();
	});
	
	//*******************************************
	//*******
	//******* ---- Hash Management ----
	//*******
	//*******************************************
	
	var clearAnyHash = function clearAnyHash() {
		if (w.location.hash) {
			w.history.replaceState(undefined, undefined, w.location.pathname);
		}
	};
	
	//*******************************************
	//*******
	//******* ---- Fullscreen API
	//*******
	//*******************************************
	
	requestFullscreenButtonEl.addEventListener("click", function (e) {
		var requestFullScreen = htmlEl.requestFullscreen || htmlEl.mozRequestFullScreen || htmlEl.webkitRequestFullScreen;
	
		requestFullScreen.call(htmlEl);
	});
	
	exitFullscreenButtonEl.addEventListener("click", function (e) {
		var exitFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen;
	
		exitFullScreen.call(doc);
	});
	
	//*******************************************
	//*******
	//******* ---- Refresh from Standalone
	//*******
	//*******************************************
	
	var mobileRefreshEl = doc.querySelector(".mobile-menu__refresh");
	
	mobileRefreshEl.addEventListener("click", function (e) {
		e.preventDefault();
		w.location = "https://bellandwhistle.net/lifey";
	});
	
	//*******************************************
	//*******
	//******* ---- Mobile-only UI
	//*******
	//*******************************************
	
	var onPointerStartAnyPanelButton = function onPointerStartAnyPanelButton(e) {
		if (e.type === "touchstart") {
			e.preventDefault();
	
			// :active styling is screwed up on FF for Android.
			// Manually add and remove classes instead. :/
			this.classList.add("panel__button--touch-pressed");
		}
		openCloseMobileFlyouts(e, this);
	};
	
	var onTouchEndAnyPanelButton = function onTouchEndAnyPanelButton(e) {
		e.preventDefault();
		this.classList.remove("panel__button--touch-pressed");
	};
	
	var openCloseMobileFlyouts = function () {
		var activeFlyout = void 0;
		var flyoutTargets = {
			"meter": {
				"buttonEl": meterButtonMobileEl,
				"targetEl": playerPanelEl,
				"className": "player--mobile-show-speed"
			},
			"menu": {
				"buttonEl": menuButtonMobileEl,
				"targetEl": playerPanelEl,
				"className": "player--mobile-show-toroidal"
			},
			"patterns": {
				"buttonEl": patternsButtonMobileEl,
				"targetEl": patternsPanelEl,
				"className": "patterns--mobile-show"
			}
		};
	
		return function (e, button) {
	
			// Could be "meter", "menu", "patterns" or undefined.
			var pointeredStr = void 0;
	
			if (button) {
				pointeredStr = button.getAttribute("data-mobile-button");
			}
	
			// Unified closing logic:
			// If the clicked button is currently active, close it and return.
			// If another flyout is active, close it.
			if (activeFlyout) {
				var activeTarget = flyoutTargets[activeFlyout];
				activeTarget.buttonEl.classList.remove("panel__button--selected");
				activeTarget.targetEl.classList.remove(activeTarget.className);
	
				// If clicked button was currently active, get out.
				if (pointeredStr && pointeredStr === activeFlyout) {
					activeFlyout = undefined;
					return;
				}
				activeFlyout = undefined; /* May be overridden below. */
			}
	
			// Opening logic:
			if (button) {
				var pointeredTarget = flyoutTargets[pointeredStr];
				if (!pointeredTarget) {
					return;
				}
				pointeredTarget.buttonEl.classList.add("panel__button--selected");
				pointeredTarget.targetEl.classList.add(pointeredTarget.className);
				activeFlyout = pointeredStr;
			}
		};
	}();
	
	// This works on all panel buttons everywhere. So canvas size, save as, share buttons all
	// close any current flyout.
	Gator(bodyEl).on(["touchstart", "click"], ".panel__button", onPointerStartAnyPanelButton);
	
	// Hamburger menu item click should close the hamburger menu.
	// Use click instead of touchstart here to reduce glitching on the menu item handlers,
	// which fire on touchstart.
	Gator(playerToroidalWrapperEl).on("click", ".mobile-menu__item", openCloseMobileFlyouts);
	
	Gator(bodyEl).on("touchend", ".panel__button", onTouchEndAnyPanelButton);
	
	// On touch, tapping tortoise/hare should increment/decrement the input range slider.
	Gator(playerSpeedEl).on("touchstart", "svg", function (e) {
		var val = this.classList.contains("player__tortoise") ? -1 : 1;
		player.setSpeed(null, parseInt(playerSpeedInputEl.value, 10) + val);
	});
	
	//*******************************************
	//*******
	//******* ---- Scrollbar Styles for Firefox
	//*******
	//*******************************************
	
	// Firefox currently doesn't support CSS on scrollbars.
	// Use overlaid dummy elements and CSS mix-blend-mode to style.
	// This is gross but it's better than either of the alternatives.
	
	var addFirefoxScrollStyleElements = function addFirefoxScrollStyleElements() {
	
		var widthInvert = doc.createElement("div");
		var widthLighter = doc.createElement("div");
		var heightInvert = doc.createElement("div");
		var heightLighter = doc.createElement("div");
		var cornerBox = doc.createElement("div");
	
		var heightInvertPatterns = void 0,
		    heightLighterPatterns = void 0,
		    heightSingleLine = void 0;
	
		widthInvert.classList.add("ff-scroll", "ff-scroll--horizontal", "ff-scroll--invert");
		widthLighter.classList.add("ff-scroll", "ff-scroll--horizontal", "ff-scroll--lighter");
		heightInvert.classList.add("ff-scroll", "ff-scroll--vertical", "ff-scroll--invert");
		heightLighter.classList.add("ff-scroll", "ff-scroll--vertical", "ff-scroll--lighter");
	
		cornerBox.classList.add("ff-scroll", "ff-scroll-corner");
	
		// Clone a full-height set for the patterns panel.
		heightInvertPatterns = heightInvert.cloneNode();
		heightInvertPatterns.classList.add("ff-scroll--full-height");
		heightLighterPatterns = heightLighter.cloneNode();
		heightLighterPatterns.classList.add("ff-scroll--full-height");
	
		// Divs on the main background need to save room for a corner.
		widthInvert.classList.add("ff-scroll--horizontal-with-corner");
		widthLighter.classList.add("ff-scroll--horizontal-with-corner");
		heightInvert.classList.add("ff-scroll--vertical-with-corner");
		heightLighter.classList.add("ff-scroll--vertical-with-corner");
	
		heightSingleLine = doc.createElement("div");
		heightSingleLine.classList.add("ff-scroll", "ff-scroll--vertical", "ff-scroll--full-height", "ff-scroll--single-line");
	
		// Main panels need to sit in front of the FF color-flipping divs
		// otherwise there are weird compositing glitches.
		bodyEl.insertBefore(widthInvert, toolboxEl);
		bodyEl.insertBefore(widthLighter, toolboxEl);
		bodyEl.insertBefore(heightInvert, toolboxEl);
		bodyEl.insertBefore(heightLighter, toolboxEl);
		bodyEl.insertBefore(cornerBox, toolboxEl);
	
		patternsOuterWrapperEl.appendChild(heightInvertPatterns);
		patternsOuterWrapperEl.appendChild(heightLighterPatterns);
	
		// Black 1px line prevents an occasional weird white line from rendering.
		patternsOuterWrapperEl.appendChild(heightSingleLine);
	};
	
	if (w.browser.isFirefox) {
		addFirefoxScrollStyleElements();
	}
	
	// No way to disable browser-level zoom in Firefox. Rebuild styles on both load and resize.
	// Add rules to existing stylesheet to indent desktop toolbars on the right by the scrollbar width.
	var writeScrollbarDependentRules = function writeScrollbarDependentRules() {
	
		var rulesLength = scrollSs.cssRules.length;
		for (var _i11 = 0; _i11 < rulesLength; _i11 += 1) {
			scrollSs.deleteRule(0);
		}
	
		// Always on page load for all browsers.
		scrollSs.insertRule(".panel--right { right: " + state.scrollbarDim + "px;}", 0);
	
		if (w.browser.isFirefox) {
			scrollSs.insertRule(".ff-scroll--horizontal {" + "height: " + state.scrollbarDim + "px;", 1);
	
			scrollSs.insertRule(".ff-scroll--vertical  {" + "width: " + state.scrollbarDim + "px;", 2);
	
			scrollSs.insertRule(".ff-scroll--horizontal-with-corner {" + "width: calc(100% - " + state.scrollbarDim + "px);}", 3);
	
			scrollSs.insertRule(".ff-scroll--vertical-with-corner {" + "height: calc(100% - " + state.scrollbarDim + "px);}", 4);
	
			scrollSs.insertRule(".ff-scroll-corner { width: " + state.scrollbarDim + "px;" + "height: " + state.scrollbarDim + "px);}", 5);
		}
	};
	
	//*******************************************
	//*******
	//******* ---- Master Window Resize Handler
	//*******
	//*******************************************
	
	// Refer to different padding values in base.SCSS starting at line 46.
	var deriveViewportDependentConstants = function deriveViewportDependentConstants() {
	
		// Track mobile vs desktop state, for layout math.
		// Current this is only needed to deal with changing scrollbars and padding.
		w.browser.isBig = false;
		state.canvas.zoomPadding = 100;
	
		// These breakpoints must match the breakpoints on line 17 of "_vars.scss"
		if (w.matchMedia("(min-width: 790px) and (min-height: 600px)").matches) {
			state.canvas.zoomPadding = 200;
			w.browser.isBig = true;
	
			// Don't track mouse cursor position if we're not actually showing it.
			canvasEl.addEventListener("mouseenter", handleCoordinatesEnter);
		}
	
		// Scrollbar CSS pixel thickness varies between browsers and sometimes zoom levels.
		state.scrollbarDim = outerBgEl.offsetWidth - outerBgEl.clientWidth;
	};
	
	var onWindowResize = function onWindowResize() {
		deriveViewportDependentConstants();
		if (w.browser.isFirefox) {
			writeScrollbarDependentRules();
		}
		innerView.onResize();
	};
	
	//*******************************************
	//*******
	//******* ---- On Window Load ----
	//*******
	//*******************************************
	
	// Some CSS values can't be read and stored reliably until the load event.
	// Wait, otherwise scaling doesn't work reliably on the initial canvas.
	(function () {
	
		var splashTimeout = void 0;
	
		var loadBlankCanvasBasedOnViewportDimensions = function loadBlankCanvasBasedOnViewportDimensions() {
	
			var initialWidth = void 0,
			    initialHeight = void 0;
	
			// 80% of the available viewport on desktop. More tightly fitted on mobile.
			if (w.browser.isBig) {
				initialWidth = Math.floor(state.innerView.visibleWidth * 0.8 / state.canvas.scale);
				initialHeight = Math.floor(state.innerView.visibleHeight * 0.8 / state.canvas.scale);
			} else {
				initialWidth = Math.floor((state.innerView.visibleWidth - 30) / state.canvas.scale);
				initialHeight = Math.floor((state.innerView.visibleHeight - 30) / state.canvas.scale);
			}
			canvas.setCanvasDim(initialWidth, initialHeight);
			canvas.clearDataArray(); // Data Array based on canvas dim state so must come after.
		};
	
		var loadInitialCanvas = function loadInitialCanvas() {
			var hash = w.location.hash.slice(1); // Remove "#"
			var link = doc.querySelector("[href='pat/" + hash + ".json']");
			var qsObj = ut.deserializeQueryString(hash);
	
			// Show the red navigator outline;
			navOutlineEl.classList.remove("navigator__canvas-outline--hidden");
	
			// First try parsing as a query string.
			if (qsObj && qsObj.pattern && qsObj.width && qsObj.height) {
	
				// Query string might be malformed or mistyped etc. Fall through to blank canvas.
				try {
					loadPatternJSONToCanvas(qsObj, true); // Do add margins in queryString.
				} catch (e) {
					console.log("Error parsing query string: ", e);
					loadBlankCanvasBasedOnViewportDimensions();
				}
	
				// Else if hash is a named pattern for which a pattern link exists, "click" that link.
			} else if (link) {
				link.click();
			} else {
				loadBlankCanvasBasedOnViewportDimensions();
			}
	
			// Add innerView listeners once canvas exists.
			/// Firefox on Android fires mysterious early resize events.
			w.addEventListener("resize", ut.debounce(onWindowResize, 80));
			outerBgEl.addEventListener("scroll", ut.throttleRaf(innerView.onScroll));
	
			// Drag-scroll work natively on touch, in order to get silky inertial scrolling.
			// Thus no need to bind a touchstart handler.
			innerViewEl.addEventListener("mousedown", innerView.onPointerDown);
		};
	
		var hideSplash = function hideSplash(e) {
			if (e) {
				e.preventDefault();
			}
			clearTimeout(splashTimeout);
			splashEl.removeEventListener("touchstart", hideSplash);
			splashEl.removeEventListener("click", hideSplash);
			splashEl.parentNode.removeChild(splashEl);
			loadInitialCanvas();
		};
	
		var onPageLoad = function onPageLoad() {
	
			// Init: Read the rateInput value off of the slider.
			// Preserves slider state across cached page reload.
			player.setSpeed(undefined, playerSpeedInputEl.value);
	
			// Get scrollbar size and zoom padding dims and set in state.
			// This must come before the innerView calcs.
			deriveViewportDependentConstants();
			writeScrollbarDependentRules();
	
			// Sets the state.innerView.visibleWidth based on viewport and scrollbar thickness.
			innerView.getVisibleDimensions();
	
			// Width and visibleWidth states will initially be equal.
			state.innerView.width = state.innerView.visibleWidth;
			state.innerView.height = state.innerView.visibleHeight;
	
			// Needed for resize handle hover areas to be placed correctly.
			patternPanel.recordComputedStyle();
	
			if (browser.cutsMustard) {
				if (w.location.hash) {
					hideSplash(); // Go directly when a hash is being shared.
				} else {
					splashTimeout = w.setTimeout(hideSplash, 2500);
	
					// For the impatient, allow clicking past the initial splash screen.
					splashEl.addEventListener("touchstart", hideSplash);
					splashEl.addEventListener("click", hideSplash);
				}
			}
	
			w.removeEventListener("load", onPageLoad);
		};
	
		if (doc.readyState === "complete") {
			onPageLoad();
		} else {
			w.addEventListener("load", onPageLoad);
		}
	})();
	
	//*******************************************
	//*******
	//******* ---- Expose on the window for Testing ----
	//*******
	//*******************************************
	
	// Uglify should automatically rip the block below out for production builds.
	// http://philipwalton.com/articles/how-to-unit-test-private-functions-in-javascript/
	// https://github.com/petehunt/webpack-howto
	// Note that this line will throw a "condition always true" warning in webpack dev builds.
	if (true) {
		w.Flingable = function () {
			return Flingable;
		};
		w.Resizable = function () {
			return Resizable;
		};
		w.ut = function () {
			return ut;
		};
		w.Modal = function () {
			return Modal;
		};
		w.modalCanvasSize = function () {
			return modalCanvasSize;
		};
		w.modalOpenPattern = function () {
			return modalOpenPattern;
		};
		w.modalSavePattern = function () {
			return modalSavePattern;
		};
		w.modalSharePattern = function () {
			return modalSharePattern;
		};
		w.parseRLEPixelString = function () {
			return parseRLEPixelString;
		};
		w.parseBMP = function () {
			return parseBMP;
		};
		w.patToRleFileString = function () {
			return patToRleFileString;
		};
		w.dataArrayToRLE = function () {
			return dataArrayToRLE;
		};
		w.saveTextAsFile = function () {
			return saveTextAsFile;
		};
	
		w.state = function () {
			return state;
		};
		w.innerView = function () {
			return innerView;
		};
		w.canvas = function () {
			return canvas;
		};
	}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	// Flingable
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	
		return {
	
			initFlingable: function initFlingable(elem, opts) {
				this.element = elem;
				this.background = document.querySelector(".outer-background");
				this.flingCoast = false; // Default
				if (opts) {
					this.flingCoast = !!opts.coast;
					if (opts.flingFriction) {
						this.flingFriction = opts.flingFriction;
					}
					if (opts.flingHandleEl) {
						this.flingHandleEl = opts.flingHandleEl;
					}
					if (opts.flingContainer) {
						this.flingContainer = Object.create(null);
						this.flingContainer.element = opts.flingContainer;
						this.flingContainer.css = Object.create(null);
					}
				}
	
				// Initial properties specific to the instance.
				if (!this.css) {
					this.css = Object.create(null);
				}
				this.isFlingDragging = false;
				this.isFlingMoving = false;
				this.flingDragPositionX = 0;
				this.flingDragPositionY = 0;
	
				this.flingPositionX = 0;
				this.flingPositionY = 0;
				this.flingVelocityX = 0;
				this.flingVelocityY = 0;
				this.flingAccelX = 0;
				this.flingAccelY = 0;
	
				// Create bound local reference for all the prototype handler methods  :/
				this.flingMouseDown = this.flingMouseDown.bind(this);
				this.flingMouseMove = this.flingMouseMove.bind(this);
				this.flingMouseUp = this.flingMouseUp.bind(this);
	
				var elemToListenOn = this.element;
				if (this.flingHandleEl) {
					elemToListenOn = this.flingHandleEl;
				}
	
				elemToListenOn.addEventListener("mousedown", this.flingMouseDown);
	
				return this; // Make chainable.
			},
	
			// On the prototype, figure out if unprefixed 2D Transforms are supported.
			// If not, check for prefix support.
			transformProp: function (w) {
				var htmlElStyle = w.getComputedStyle(document.documentElement);
				var prefixArr = ["webkit", "ms"];
				var prefixProp;
				if ("transform" in htmlElStyle) {
					return "transform";
				}
				for (var i = 0; i < 2; i += 1) {
					prefixProp = prefixArr[i] + "Transform";
					if (prefixProp in htmlElStyle) {
						return "-" + prefixArr[i] + "-transform";
					}
				}
			}(window),
	
			flingMouseDown: function flingMouseDown(event) {
				event.preventDefault();
	
				// Don't fling if this is a resize.
				if (this.rzblHoveringEdge) {
					return;
				}
	
				this.element.classList.add("panel--is-flinging");
				this.background.classList.add("panel--is-flinging");
	
				// Container may have changed dimensions since init, e.g. viewport resize.
				this.measureContainers();
	
				// Get drag start positions.
				this.flingPageStartX = event.pageX;
				this.flingPageStartY = event.pageY;
	
				// The flingDragPosition may reflect the last mouseup position,
				// not the final resting place, and thus needs to be updated.
				this.flingItemBeginX = this.flingDragPositionX = this.flingPositionX;
				this.flingItemBeginY = this.flingDragPositionY = this.flingPositionY;
	
				this.isFlingDragging = this.isFlingMoving = true;
	
				// Start a rAF animation loop
				this.flingAnimate();
	
				// Catch all mouse activity, even outside the browser viewport.
				window.addEventListener("mousemove", this.flingMouseMove);
				window.addEventListener("mouseup", this.flingMouseUp);
			},
	
			flingMouseMove: function flingMouseMove(event) {
	
				// Mousemove updates the flingDragPosition, which is one event ahead of the
				// flingPosition. The difference between the two is what generates the
				// velocity calculations around line 263. The velocity, adjusted for drag,
				// is then applied to the flingPosition, which is what is rendered out.
				var moveX = event.pageX - this.flingPageStartX;
				var moveY = event.pageY - this.flingPageStartY;
	
				this.flingDragPositionX = this.flingItemBeginX + moveX;
				this.flingDragPositionY = this.flingItemBeginY + moveY;
			},
	
			flingMouseUp: function flingMouseUp() {
				this.isFlingDragging = false;
	
				if (!this.flingCoast) {
					this.isFlingMoving = false; // Stop the animation.
					this.flingVelocityX = this.flingVelocityY = 0;
				}
	
				this.element.classList.remove("panel--is-flinging");
				this.background.classList.remove("panel--is-flinging");
	
				window.removeEventListener("mousemove", this.flingMouseMove);
				window.removeEventListener("mouseup", this.flingMouseUp);
			},
	
			flingAnimate: function flingAnimate() {
	
				var that = this;
				if (!this.isFlingMoving || !this.isFlingDragging && !this.flingCoast) {
	
					// Animation is over, update the final boundingRect.
					this.css.boundRect = this.element.getBoundingClientRect();
					return;
				}
				this.applyDragForce();
	
				// Containment option.
				if (this.flingContainer) {
					this.flingPositionX = this.containFling("x", this.flingPositionX);
					this.flingPositionY = this.containFling("y", this.flingPositionY);
				}
	
				this.renderFling();
	
				requestAnimationFrame(function () {
					that.flingAnimate();
				});
			},
	
			renderFling: function renderFling() {
	
				// Round the final translation numbers to three decimal places when it stops.
				this.flingPositionX = Math.round(this.flingPositionX * 1000) / 1000;
				this.flingPositionY = Math.round(this.flingPositionY * 1000) / 1000;
	
				var str = "translate(" + this.flingPositionX + "px, " + this.flingPositionY + "px)";
				if (this.scale) {
					str += " scale(" + this.scale + ")";
				}
				this.element.style[this.transformProp] = str;
	
				// Store the properties
				this.css.translateX = this.flingPositionX;
				this.css.translateY = this.flingPositionY;
			},
	
			flingFriction: 0.93,
	
			applyDragForce: function applyDragForce() {
				if (this.isFlingDragging) {
	
					// Change the position to drag position by applying force to acceleration
					var flingVelocityX = this.flingDragPositionX - this.flingPositionX;
					var flingForceX = flingVelocityX - this.flingVelocityX;
	
					var flingVelocityY = this.flingDragPositionY - this.flingPositionY;
					var flingForceY = flingVelocityY - this.flingVelocityY;
	
					this.flingAccelX += flingForceX;
					this.flingAccelY += flingForceY;
				}
	
				this.flingVelocityX += this.flingAccelX;
				this.flingVelocityX *= this.flingFriction;
				this.flingPositionX += this.flingVelocityX;
	
				this.flingVelocityY += this.flingAccelY;
				this.flingVelocityY *= this.flingFriction;
				this.flingPositionY += this.flingVelocityY;
	
				// If the last update was miniscule, set isMoving to break the rAF loop.
				if (Math.abs(this.flingVelocityX) < 0.001 && Math.abs(this.flingVelocityY) < 0.001 && !this.isFlingDragging) {
					this.isFlingMoving = false;
				}
	
				this.flingAccelX = 0;
				this.flingAccelY = 0;
			},
	
			measureContainers: function measureContainers() {
				this.css.boundRect = this.element.getBoundingClientRect();
	
				// Note: getBoundingClientRect is with transforms applied.
				// offset positions are without transforms applied.
				this.css.offsetTop = this.element.offsetTop;
				this.css.offsetLeft = this.element.offsetLeft;
	
				if (this.flingContainer && this.flingContainer.element) {
					this.flingContainer.css.boundRect = this.flingContainer.element.getBoundingClientRect();
				}
			},
	
			// Axis is 'x' or 'y' string, drag is numeric value
			containFling: function containFling(axis, drag) {
				var span = axis === "x" ? "width" : "height";
				var offsetDirection = axis === "x" ? "Left" : "Top";
	
				var min = -1 * this.css["offset" + offsetDirection];
				var max = this.flingContainer.css.boundRect[span] - this.css.boundRect[span] + min;
	
				return Math.min(max, Math.max(min, drag));
			}
		};
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ut) {
	
		return {
	
			initResizable: function initResizable(elem, opts) {
				var that = this;
				this.element = elem;
	
				// Copy options onto the local object
				if (opts) {
					for (var opt in opts) {
	
						if (opts.hasOwnProperty(opt)) {
							this[opt] = opts[opt];
						}
					}
				}
	
				// Check first, might be inheriting.
				if (!this.css) {
					this.css = Object.create(null);
				}
	
				// Initial properties specific to the object.
				this.isResizing = false;
				this.rzblOnTopEdge = false;
				this.rzblOnRightEdge = false;
				this.rzblOnBottomEdge = false;
				this.rzblOnLeftEdge = false;
				this.rzblDragStartX = 0;
				this.rzblDragStartY = 0;
	
				this.rzblCalcEdges = this.rzblCalcEdges.bind(this);
	
				this.recordComputedStyle = this.recordComputedStyle.bind(this);
				this.rzblMouseDown = this.rzblMouseDown.bind(this);
				this.rzblMouseMove = this.rzblMouseMove.bind(this);
				this.rzblMouseUp = this.rzblMouseUp.bind(this);
	
				// Must wait for load/layout to internally record the resolved values of CSS
				// properties. This must happen after the scrollbar width is calculated.
				var recordComputedStyleOnLoad = function recordComputedStyleOnLoad() {
					that.recordComputedStyle();
					window.removeEventListener("load", recordComputedStyleOnLoad, true);
				};
	
				if (document.readyState === "complete") {
					recordComputedStyleOnLoad();
				} else {
					window.addEventListener("load", recordComputedStyleOnLoad, true);
				}
	
				window.addEventListener("resize", ut.debounce(this.recordComputedStyle, 80), true);
				window.addEventListener("mousemove", this.rzblMouseMove, true);
				window.addEventListener("mousedown", this.rzblMouseDown, true);
	
				return this; // Chainability
			},
	
			recordComputedStyle: function recordComputedStyle() {
				var computedStyle = window.getComputedStyle(this.element);
				this.css.boundRect = this.element.getBoundingClientRect();
				this.css.top = ut.stripPixelUnits(computedStyle.top);
				this.css.right = ut.stripPixelUnits(computedStyle.right);
				this.css.bottom = ut.stripPixelUnits(computedStyle.bottom);
				this.css.left = ut.stripPixelUnits(computedStyle.left);
			},
	
			// Default settings live on the prototype.
			rzblTop: true,
			rzblRight: true,
			rzblBottom: true,
			rzblLeft: true,
			rzblHorizontalCssProp: "left",
			rzblVerticalCssProp: "top",
			rzblMinHeight: 100,
			rzblMinWidth: 100,
			rzblTolerance: 4,
	
			// Meaure cursor's proximity to the edges of the box.
			// Returns one of the following: "top" "right" "left" "bottom" or false
			rzblCalcEdges: function rzblCalcEdges(e) {
				if (!this.css.boundRect) {
					return; // Layout hasn't happened yet, get out.
				}
				var boundTop = this.css.boundRect.top;
				var boundRight = this.css.boundRect.right;
				var boundBottom = this.css.boundRect.bottom;
				var boundLeft = this.css.boundRect.left;
				var clientX = e.clientX;
				var clientY = e.clientY;
				var tol = this.rzblTolerance;
				var hoveredEdge = false;
	
				var withinElementX = boundLeft <= clientX && clientX <= boundRight;
				var withinElementY = boundTop <= clientY && clientY <= boundBottom;
	
				var nearTopLine = Math.abs(clientY - boundTop) <= tol;
				var nearRightLine = Math.abs(clientX - boundRight) <= tol;
				var nearBottomLine = Math.abs(clientY - boundBottom) <= tol;
				var nearLeftLine = Math.abs(clientX - boundLeft) <= tol;
	
				if (nearTopLine && withinElementX && this.rzblTop) {
					hoveredEdge = "top";
				} else if (nearRightLine && withinElementY && this.rzblRight) {
					hoveredEdge = "right";
				} else if (nearBottomLine && withinElementX && this.rzblBottom) {
					hoveredEdge = "bottom";
				} else if (nearLeftLine && withinElementY && this.rzblLeft) {
					hoveredEdge = "left";
				}
	
				// Will be false when mouse leaves edge zone.
				// Assign at the top so canvas drawing can check.
				// Don't yet assign to the local object.
				// this.rzblHoveredEdge = isHoveringEdge;
				if (typeof this.rzblIsHovering === "function") {
					this.rzblIsHovering(hoveredEdge);
				}
				if (hoveredEdge) {
					e.stopPropagation();
				}
				return hoveredEdge;
			},
	
			rzblApplyCursorClass: function rzblApplyCursorClass() {
				var bodyEl = document.body;
				var outerBgEl = document.querySelector(".outer-background");
				var panelEl = this.element;
	
				if (this.rzblHoveredEdge === "top" || this.rzblHoveredEdge === "bottom") {
					if (this.cursor !== "ns") {
						this.cursor = "ns";
						bodyEl.classList.add("ns-resize-cursor");
						outerBgEl.classList.add("ns-resize-cursor");
						panelEl.classList.add("ns-resize-cursor");
					}
				} else if (this.rzblHoveredEdge === "right" || this.rzblHoveredEdge === "left") {
					if (this.cursor !== "ew") {
						this.cursor = "ew";
						bodyEl.classList.add("ew-resize-cursor");
						outerBgEl.classList.add("ew-resize-cursor");
						panelEl.classList.add("ew-resize-cursor");
					}
				} else if (!this.isResizing) {
					if (this.cursor) {
						this.cursor = "";
						bodyEl.classList.remove("ns-resize-cursor", "ew-resize-cursor");
						outerBgEl.classList.remove("ns-resize-cursor", "ew-resize-cursor");
						panelEl.classList.remove("ns-resize-cursor", "ew-resize-cursor");
					}
				}
			},
	
			rzblMouseDown: function rzblMouseDown(e) {
				var abort = false;
				if (this.rzblAbortResize) {
					abort = this.rzblAbortResize();
				}
	
				if (!this.rzblHoveredEdge || abort) {
					return;
				}
	
				e.stopPropagation();
	
				this.rzblEdgeClicked = this.rzblHoveredEdge; // E.g. "left"
	
				// Allows the resize animation to loop, also checked by canvas paint/erase.
				// A single property for all panels?
				this.isResizing = true;
				if (this.reportResizing) {
					this.reportResizing(true);
				}
	
				this.recordComputedStyle();
	
				this.rzblDragStartX = e.clientX;
				this.rzblDragStartY = e.clientY;
				this.rzblMoveX = 0;
				this.rzblMoveY = 0;
	
				// These values can be either right or left, top or bottom CSS.
				this.flingItemBeginX = this.css[this.rzblHorizontalCssProp];
				this.flingItemBeginY = this.css[this.rzblVerticalCssProp];
	
				// Start a rAF animation loop
				this.rzblAnimate();
	
				window.addEventListener("mouseup", this.rzblMouseUp, true);
			},
	
			rzblMouseMove: function rzblMouseMove(e) {
				var currentHoveredEdge = this.rzblHoveredEdge;
				var newHoveredEdge = this.rzblCalcEdges(e);
	
				if (this.isResizing) {
	
					// Set the "move" properties, which will get
					// picked up in the animation loop.
					if (this.rzblEdgeClicked === "top" || this.rzblEdgeClicked === "bottom") {
						this.rzblMoveY = e.pageY - this.rzblDragStartY;
					} else if (this.rzblEdgeClicked === "right" || this.rzblEdgeClicked === "left") {
						this.rzblMoveX = e.pageX - this.rzblDragStartX;
					}
				} else {
	
					// Modify the cursors on hover/hoverend, but only if we're not already
					// resizing.
					this.rzblHoveredEdge = newHoveredEdge;
	
					// If already painting near the panel edge, don't apply the resize cursor class.
					if (this.rzblAbortResize && this.rzblAbortResize()) {
						return;
					}
	
					// Don't touch the DOM if there hasn't been a change.
					if (newHoveredEdge !== currentHoveredEdge) {
						this.rzblApplyCursorClass();
					}
				}
			},
	
			rzblMouseUp: function rzblMouseUp(e) {
	
				// Breaks the resize animation loop, also checked by canvas paint/erase
				this.isResizing = false;
				if (this.reportResizing) {
					this.reportResizing(false);
				}
	
				// Flushing these seems to reduce glitching
				this.rzblEdgeClicked = undefined;
	
				// Mouseups can always propagate.
				window.removeEventListener("mouseup", this.rzblMouseUp, true);
			},
	
			rzblAnimate: function rzblAnimate() {
				var that = this;
				if (!this.isResizing) {
	
					// Animation is over. Update the box after resize complete
					this.css.boundRect = this.element.getBoundingClientRect();
					return; // Get out when mouseup breaks the animation loop.
				}
				this.rzblRender();
				requestAnimationFrame(function () {
					that.rzblAnimate();
				});
			},
	
			// ========= RENDER =========================
			//
			//  Drag       |  CSS       |  Render
			//  From       |  pos prop  |  Outcome
			// ------------------------------------------
			//  left       |  left      | + left
			//             |            | - width
			// ------------------------------------------
			//  left       |  right     | - width
			//             |            |
			// ------------------------------------------
			//  right      |  right     | - right
			//             |            | + width
			// ------------------------------------------
			//  right      |  left      | + width
			//             |            |
			// ------------------------------------------
			//  top        |  top       | + top
			//             |            | - height
			// ------------------------------------------
			//  top        |  bottom    | - height
			//             |            |
			// ------------------------------------------
			//  bottom     |  bottom    | - bottom
			//             |            | + height
			// ------------------------------------------
			//  bottom     |  top       | + height
			//             |            |
			// ------------------------------------------
	
			rzblRender: function rzblRender() {
				if (this.rzblEdgeClicked === "left") {
					if (this.rzblHorizontalCssProp === "left") {
						this.css.left = this.flingItemBeginX + this.rzblMoveX;
						this.element.style.left = this.css.left + "px";
					}
					this.element.style.width = this.css.boundRect.width - this.rzblMoveX + "px";
				} else if (this.rzblEdgeClicked === "right") {
					if (this.rzblHorizontalCssProp === "right") {
						this.css.right = this.flingItemBeginX - this.rzblMoveX;
						this.element.style.right = this.css.right + "px";
					}
					this.element.style.width = this.css.boundRect.width + this.rzblMoveX + "px";
				} else if (this.rzblEdgeClicked === "top") {
					if (this.rzblVerticalCssProp === "top") {
						this.css.top = this.flingItemBeginY + this.rzblMoveY;
						this.element.style.top = this.css.top + "px";
					}
					this.element.style.height = this.css.boundRect.height - this.rzblMoveY + "px";
				} else if (this.rzblEdgeClicked === "bottom") {
					if (this.rzblVerticalCssProp === "bottom") {
						this.css.bottom = this.css.bottom - this.rzblMoveY;
						this.element.style.bottom = this.css.bottom + "px";
					}
					this.element.style.height = this.css.boundRect.height + this.rzblMoveY + "px";
				}
			}
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	
		// Currently needed just for Intern to allow block-scoping. Possibly delete in build?
		"use strict";
	
		return {
	
			// http://www.jacklmoore.com/notes/rounding-in-javascript/
			round: function round(value, decimalPlaces) {
				return Number(Math.round(value + "e" + decimalPlaces) + "e-" + decimalPlaces);
			},
	
			// Http://modernjavascript.blogspot.com/2013/08/building-better-debounce.html
			debounce: function debounce(func, wait) {
	
				// We need to save these in the closure
				var timeout = void 0,
				    args = void 0,
				    context = void 0,
				    timestamp = void 0;
	
				return function () {
	
					// Save details of latest call
					context = this;
					args = [].slice.call(arguments, 0);
					timestamp = new Date();
	
					// This is where the magic happens
					var later = function later() {
	
						// How long ago was the last call
						var last = new Date() - timestamp;
	
						// If the latest call was less that the wait period ago
						// then we reset the timeout to wait for the difference
						if (last < wait) {
							timeout = setTimeout(later, wait - last);
	
							// Or if not we can null out the timer and run the latest
						} else {
							timeout = null;
							func.apply(context, args);
						}
					};
	
					// We only need to set the timer now if one isn't already running
					if (!timeout) {
						timeout = setTimeout(later, wait);
					}
				};
			},
	
			throttleRaf: function throttleRaf(func) {
				var args = void 0,
				    context = void 0,
				    ticking = void 0;
	
				return function () {
	
					// Save details of latest call, e.g. event properties.
					context = this;
					args = [].slice.call(arguments, 0);
	
					var later = function later() {
						func.apply(context, args);
						ticking = false;
					};
	
					if (!ticking) {
						requestAnimationFrame(later);
						ticking = true;
					}
				};
			},
	
			// Get closest DOM element up the tree that contains a class, ID, or data attribute
			// @param  {Node} elem The base element
			// @param  {String} selector The class, id, data attribute, or tag to look for
			// @return {Node} Null if no match
			// http://gomakethings.com/climbing-up-and-down-the-dom-tree-with-vanilla-javascript/
			getClosest: function getClosest(elem, selector) {
				var firstChar = selector.charAt(0);
	
				// Get closest match
				for (; elem && elem !== document; elem = elem.parentNode) {
	
					// If selector is a class
					if (firstChar === ".") {
						if (elem.classList.contains(selector.substr(1))) {
							return elem;
						}
					}
	
					// If selector is an ID
					if (firstChar === "#") {
						if (elem.id === selector.substr(1)) {
							return elem;
						}
					}
	
					// If selector is a data attribute
					if (firstChar === "[") {
						if (elem.hasAttribute(selector.substr(1, selector.length - 2))) {
							return elem;
						}
					}
	
					// If selector is a tag
					if (elem.tagName.toLowerCase() === selector) {
						return elem;
					}
				}
				return false;
			},
	
			extend: function extend() {
				for (var i = 1; i < arguments.length; i += 1) {
					for (var key in arguments[i]) {
						if (arguments[i].hasOwnProperty(key)) {
							arguments[0][key] = arguments[i][key];
						}
					}
				}
				return arguments[0];
			},
	
			isDigit: function isDigit(n) {
				return Boolean([true, true, true, true, true, true, true, true, true, true][n]);
			},
	
			isNonNegativeInteger: function isNonNegativeInteger(val) {
				return Number.isFinite(val) && val % 1 === 0 && val >= 0;
			},
	
			stripPixelUnits: function stripPixelUnits(str) {
				var ret = str.replace(/px$/i, "");
	
				// Avoid converting "auto" to NaN, but still coerce "6px" to the number 6.
				if (this.isDigit(str[0])) {
					ret = parseFloat(ret);
				}
				return ret;
			},
	
			// @param  {object}
			// @return {string}
			serializeToQueryString: function serializeToQueryString(obj) {
				var ret = "";
				for (var prop in obj) {
					ret += prop + "=" + obj[prop] + "&";
				}
				if (ret) {
					ret = ret.slice(0, -1); // Remove final trailing ampersand.
				}
				return ret;
			},
	
			deserializeQueryString: function deserializeQueryString(str) {
				var ret = Object.create(null);
				if (str.indexOf("?") > -1) {
					str = str.split("?")[1];
				}
				var pairs = str.split("&");
				pairs.forEach(function (pair) {
					pair = pair.split("=");
					ret[pair[0]] = decodeURIComponent(pair[1] || "");
				});
				return ret;
			},
	
			selectContents: function selectContents(el) {
	
				// FF doesn"t support select() method.
				// Webkit throws InvalidStateError on setSelectionRange on an input type=number.
				// https://code.google.com/p/chromium/issues/detail?id=346270
				try {
					el.focus();
					el.setSelectionRange(0, 9999);
				} catch (e) {
					el.select();
				}
				return el;
			},
	
			copyTextToClipBoard: function copyTextToClipBoard(text) {
				var input = document.createElement("textarea");
				document.body.appendChild(input);
				input.value = text;
				this.selectContents(input);
				document.execCommand("Copy");
				document.body.removeChild(input);
				return text;
			}
		};
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	//Modal
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	
		// Opening modal changes keymaster "scope"
		var key = __webpack_require__(5);
	
		// To be customized per unique modal object:
		// this.innerMarkup   html to insert
		// this.modalInternalBinding   listeners other than ok/cancel
		// this.modalInternalUnbinding  remove listeners other than ok/cancel
		// this.modalValidate  optional check on click of OK. returns a Boolean.
		// this.modalSubmit   function to run 'ok' click if valid.
	
		return {
	
			modalWrapperElement: document.querySelector(".modal-wrapper"),
	
			modalTitleEl: document.querySelector(".modal__title"),
	
			modalContentsEl: document.querySelector(".modal__contents"),
	
			init: function init(buttonElementToBind) {
				this.modalOpenButtonElement = buttonElementToBind;
	
				// Create bound local reference for all the prototype handler methods  :/
				this.modalOpen = this.modalOpen.bind(this);
				this.modalClose = this.modalClose.bind(this);
				this.modalOnOk = this.modalOnOk.bind(this);
				this.modalOnCancel = this.modalOnCancel.bind(this);
	
				// Assume for now it's always a button that triggers opening the modal.
				this.modalOpenButtonElement.addEventListener("touchstart", this.modalOpen);
				this.modalOpenButtonElement.addEventListener("click", this.modalOpen);
			},
	
			modalOpen: function modalOpen(e) {
	
				if (e.type === "touchstart") {
					e.preventDefault();
				} /* Suppress ghost click. */
	
				// The custom pre-open fn unique to a particular modal.
				if (typeof this.modalBeforeOpen === "function") {
					this.modalBeforeOpen();
				}
	
				// Generic to all Modals but set inside the closure.
				if (typeof this.modalSetOpenState === "function") {
					this.modalSetOpenState(true);
				}
	
				// Turn off all Keymaster shortcuts applicable in the main view, so that, for example,
				// tabbing works between form fields in a modal.
				// In the "modal" scope, "enter" clicks the OK button.
				key.setScope("modal");
	
				// Show the modal.
				this.modalWrapperElement.classList.remove("modal-wrapper--hide");
	
				// Insert the DOM elements
				this.modalTitleEl.innerHTML = this.titleText;
				this.modalContentsEl.innerHTML = this.innerMarkup();
	
				this.modalOkButton = document.querySelector("[data-modal-ok]");
				this.modalCancelButton = document.querySelector("[data-modal-cancel]");
	
				this.modalOkButton.addEventListener("touchstart", this.modalOnOk);
				this.modalOkButton.addEventListener("click", this.modalOnOk);
	
				// Not all modals have a cancel button.
				if (this.modalCancelButton) {
					this.modalCancelButton.addEventListener("touchstart", this.modalOnCancel);
					this.modalCancelButton.addEventListener("click", this.modalOnCancel);
				}
	
				// The custom post-open fn unique to a particular modal.
				if (this.modalInternalBinding) {
					this.modalInternalBinding();
				}
			},
	
			showError: function showError(errorText) {
				this.errorEl.innerHTML = errorText;
			},
	
			modalOnOk: function modalOnOk(e) {
	
				if (e.type === "touchstart") {
					e.preventDefault();
				} /* Suppress ghost click. */
	
				// Revalidate on click of OK.
				// Assume valid because not all modals use validation.
				if (typeof this.modalValidate === "function") {
					if (!this.modalValidate()) {
						return;
					}
				}
	
				// Some "info" modals (like share) don't do anything on submit.
				if (typeof this.modalSubmit === "function") {
					this.modalSubmit();
				}
				this.modalClose();
			},
	
			modalOnCancel: function modalOnCancel(e) {
				if (e.type === "touchstart") {
					e.preventDefault();
				} /* Suppress ghost click. */
				this.modalClose();
			},
	
			modalClose: function modalClose() {
				if (this.modalInternalUnbinding) {
					this.modalInternalBinding();
				}
	
				// Unbind confirmation buttons
				this.modalOkButton.removeEventListener("touchstart", this.modalOnOk);
				this.modalOkButton.removeEventListener("click", this.modalOnOk);
	
				if (this.modalCancelButton) {
					this.modalCancelButton.removeEventListener("touchstart", this.modalOnCancel);
					this.modalCancelButton.removeEventListener("click", this.modalOnCancel);
				}
				this.modalWrapperElement.classList.add("modal-wrapper--hide");
	
				key.setScope("main");
	
				// Generic to all Modals but set inside the closure.
				if (typeof this.modalSetOpenState === "function") {
					this.modalSetOpenState(false);
				}
	
				// The custom post-open fn unique to a particular modal.
				if (typeof this.modalAfterClose === "function") {
					this.modalAfterClose();
				}
			}
		};
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";
	
	/* Keymaster.js
	   (c) 2011-2013 Thomas Fuchs
	   keymaster.js may be freely distributed under the MIT license. */
	
	;(function (global) {
	  var k,
	      _handlers = {},
	      _mods = { 16: false, 18: false, 17: false, 91: false },
	      _scope = "all",
	
	
	  // Modifier keys
	  _MODIFIERS = {
	    "â‡§": 16, shift: 16,
	    "âŒ¥": 18, alt: 18, option: 18,
	    "âŒƒ": 17, ctrl: 17, control: 17,
	    "âŒ˜": 91, command: 91
	  },
	
	
	  // Special keys
	  _MAP = {
	    backspace: 8, tab: 9, clear: 12,
	    enter: 13, "return": 13,
	    esc: 27, escape: 27, space: 32,
	    left: 37, up: 38,
	    right: 39, down: 40,
	    del: 46, "delete": 46,
	    home: 36, end: 35,
	    pageup: 33, pagedown: 34,
	    ",": 188, ".": 190, "/": 191,
	    "`": 192, "-": 189, "=": 187,
	    ";": 186, "\'": 222,
	    "[": 219, "]": 221, "\\": 220
	  },
	      code = function code(x) {
	    return _MAP[x] || x.toUpperCase().charCodeAt(0);
	  },
	      _downKeys = [];
	
	  for (k = 1; k < 20; k++) {
	    _MAP["f" + k] = 111 + k;
	  }
	
	  // IE doesn't support Array#indexOf, so have a simple replacement
	  function index(array, item) {
	    var i = array.length;
	    while (i--) {
	      if (array[i] === item) {
	        return i;
	      }
	    }return -1;
	  }
	
	  // For comparing mods before unassignment
	  function compareArray(a1, a2) {
	    if (a1.length != a2.length) {
	      return false;
	    }
	    for (var i = 0; i < a1.length; i++) {
	      if (a1[i] !== a2[i]) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  var modifierMap = {
	    16: "shiftKey",
	    18: "altKey",
	    17: "ctrlKey",
	    91: "metaKey"
	  };
	
	  function updateModifierKey(event) {
	    for (k in _mods) {
	      _mods[k] = event[modifierMap[k]];
	    }
	  }
	
	  // Handle keydown event
	  function dispatch(event) {
	    var key, handler, k, i, modifiersMatch, scope;
	    key = event.keyCode;
	
	    if (index(_downKeys, key) == -1) {
	      _downKeys.push(key);
	    }
	
	    // If a modifier key, set the key.<modifierkeyname> property to true and return
	    if (key == 93 || key == 224) {
	      key = 91;
	    } /* right command on webkit, command on Gecko */
	    if (key in _mods) {
	      _mods[key] = true;
	
	      // 'assignKey' from inside this closure is exported to window.key
	      for (k in _MODIFIERS) {
	        if (_MODIFIERS[k] == key) {
	          assignKey[k] = true;
	        }
	      }if (!(key in _handlers)) {
	        /* allow single modifier shortcuts to execute */
	        return; /* for combinations, return and wait for the second keypress */
	      }
	    }
	    updateModifierKey(event);
	
	    // See if we need to ignore the keypress (filter() can can be overridden)
	    // by default ignore key presses if a select, textarea, or input is focused
	    if (!assignKey.filter.call(this, event)) {
	      return;
	    }
	
	    // Abort if no potentially matching shortcuts found
	    if (!(key in _handlers)) {
	      return;
	    }
	
	    scope = getScope();
	
	    // For each potential shortcut
	    for (i = 0; i < _handlers[key].length; i++) {
	      handler = _handlers[key][i];
	
	      // See if it's in the current scope
	      if (handler.scope == scope || handler.scope == "all") {
	
	        // Check if modifiers match if any
	        modifiersMatch = handler.mods.length > 0;
	        for (k in _mods) {
	          if (!_mods[k] && index(handler.mods, +k) > -1 || _mods[k] && index(handler.mods, +k) == -1) {
	            modifiersMatch = false;
	          }
	        }
	
	        // Call the handler and stop the event if neccessary
	        if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch) {
	          if (handler.method(event, handler) === false) {
	            if (event.preventDefault) {
	              event.preventDefault();
	            } else {
	              event.returnValue = false;
	            }
	            if (event.stopPropagation) {
	              event.stopPropagation();
	            }
	            if (event.cancelBubble) {
	              event.cancelBubble = true;
	            }
	          }
	        }
	      }
	    }
	  }
	
	  // Unset modifier keys on keyup
	  function clearModifier(event) {
	    var key = event.keyCode,
	        k,
	        i = index(_downKeys, key);
	
	    // Remove key from _downKeys
	    if (i >= 0) {
	      _downKeys.splice(i, 1);
	    }
	
	    if (key == 93 || key == 224) {
	      key = 91;
	    }
	    if (key in _mods) {
	      _mods[key] = false;
	      for (k in _MODIFIERS) {
	        if (_MODIFIERS[k] == key) {
	          assignKey[k] = false;
	        }
	      }
	    }
	  }
	
	  function resetModifiers() {
	    for (k in _mods) {
	      _mods[k] = false;
	    }for (k in _MODIFIERS) {
	      assignKey[k] = false;
	    }
	  }
	
	  // Parse and assign shortcut
	  function assignKey(key, scope, method) {
	    var keys, mods;
	    keys = getKeys(key);
	    if (method === undefined) {
	      method = scope;
	      scope = "all";
	    }
	
	    // For each shortcut
	    for (var i = 0; i < keys.length; i++) {
	
	      // Set modifier keys if any
	      mods = [];
	      key = keys[i].split("+");
	
	      // Account for the case where shortcut is a single modifier
	      if (key in _MODIFIERS) {
	        key = _MODIFIERS[key];
	        mods = [key];
	      }
	
	      // All other cases
	      else {
	          if (key.length > 1) {
	            mods = getMods(key);
	            key = [key[key.length - 1]];
	          }
	
	          // Convert to keycode and...
	          key = key[0];
	          key = code(key);
	        }
	
	      // ...Store handler
	      if (!(key in _handlers)) {
	        _handlers[key] = [];
	      }
	      _handlers[key].push({
	        shortcut: keys[i],
	        scope: scope,
	        method: method,
	        key: keys[i],
	        mods: mods
	      });
	    }
	  }
	
	  // Unbind all handlers for given key in current scope
	  function unbindKey(key, scope) {
	    var multipleKeys,
	        keys,
	        mods = [],
	        i,
	        j,
	        obj;
	
	    multipleKeys = getKeys(key);
	
	    for (j = 0; j < multipleKeys.length; j++) {
	      keys = multipleKeys[j].split("+");
	
	      // Account for the case where shortcut is a single modifier
	      if (key in _MODIFIERS) {
	        key = _MODIFIERS[key];
	        mods = [key];
	      }
	
	      // All other cases
	      else {
	          if (keys.length > 1) {
	            mods = getMods(keys);
	          }
	
	          key = keys[keys.length - 1];
	          key = code(key);
	        }
	
	      if (scope === undefined) {
	        scope = getScope();
	      }
	      if (!_handlers[key]) {
	        return;
	      }
	      for (i = 0; i < _handlers[key].length; i++) {
	        obj = _handlers[key][i];
	
	        // Only clear handlers if correct scope and mods match
	        if (obj.scope === scope && compareArray(obj.mods, mods)) {
	          _handlers[key][i] = {};
	        }
	      }
	    }
	  }
	
	  // Returns true if the key with code 'keyCode' is currently down
	  // Converts strings into key codes.
	  function isPressed(keyCode) {
	    if (typeof keyCode == "string") {
	      keyCode = code(keyCode);
	    }
	    return index(_downKeys, keyCode) != -1;
	  }
	
	  function getPressedKeyCodes() {
	    return _downKeys.slice(0);
	  }
	
	  function filter(event) {
	    var tagName = (event.target || event.srcElement).tagName;
	
	    // Ignore keypressed in any elements that support keyboard data input
	    return !(tagName == "INPUT" || tagName == "SELECT" || tagName == "TEXTAREA");
	  }
	
	  // Initialize key.<modifier> to false
	  for (k in _MODIFIERS) {
	    assignKey[k] = false;
	  } // Set current scope (default 'all')
	  function setScope(scope) {
	    _scope = scope || "all";
	  }
	  function getScope() {
	    return _scope || "all";
	  }
	
	  // Delete all handlers for a given scope
	  function deleteScope(scope) {
	    var key, handlers, i;
	
	    for (key in _handlers) {
	      handlers = _handlers[key];
	      for (i = 0; i < handlers.length;) {
	        if (handlers[i].scope === scope) {
	          handlers.splice(i, 1);
	        } else {
	          i++;
	        }
	      }
	    }
	  }
	
	  // Abstract key logic for assign and unassign
	  function getKeys(key) {
	    var keys;
	    key = key.replace(/\s/g, "");
	    keys = key.split(",");
	    if (keys[keys.length - 1] === "") {
	      keys[keys.length - 2] += ",";
	    }
	    return keys;
	  }
	
	  // Abstract mods logic for assign and unassign
	  function getMods(key) {
	    var mods = key.slice(0, key.length - 1);
	    for (var mi = 0; mi < mods.length; mi++) {
	      mods[mi] = _MODIFIERS[mods[mi]];
	    }return mods;
	  }
	
	  // Cross-browser events
	  function addEvent(object, event, method) {
	    if (object.addEventListener) {
	      object.addEventListener(event, method, false);
	    } else if (object.attachEvent) {
	      object.attachEvent("on" + event, function () {
	        method(window.event);
	      });
	    }
	  }
	
	  // Set the handlers globally on document
	  // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
	  addEvent(document, "keydown", function (event) {
	    dispatch(event);
	  });
	  addEvent(document, "keyup", clearModifier);
	
	  // Reset modifiers to false whenever the window is (re)focused.
	  addEvent(window, "focus", resetModifiers);
	
	  // Store previously defined key
	  var previousKey;
	
	  // Restore previously defined key and return reference to our key object
	  function noConflict() {
	    var k = global.key;
	    global.key = previousKey;
	    return k;
	  }
	
	  var toExport = assignKey;
	  toExport.setScope = setScope;
	  toExport.getScope = getScope;
	  toExport.deleteScope = deleteScope;
	  toExport.filter = filter;
	  toExport.isPressed = isPressed;
	  toExport.getPressedKeyCodes = getPressedKeyCodes;
	  toExport.noConflict = noConflict;
	  toExport.unbind = unbindKey;
	
	  // If window is available set window.key and window.key.set/get/deleteScope,
	  // and the default filter.
	  if (global) {
	    if (global.key) {
	
	      // Store for possible recovery
	      previousKey = global.key;
	    }
	    global.key = toExport;
	  }
	
	  // If requiring as module
	  //	if( typeof module !== "undefined" ) {
	  //		 module.exports = toExport;
	  //	}
	
	  // Remove from conditional to suppress Uglify warnings.
	  module.exports = toExport;
	})(undefined);

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Modal) {
	
		// To be added & customized for each unique modal objects:
		// this.titleText   html to insert in body of modal
		// this.innerMarkup   html to insert in body of modal
		// this.modalInternalBinding   listeners other than ok/cancel
		// this.modalInternalUnbinding  remove listeners other than ok/cancel
		// this.modalValidate  optional check on click of OK. returns a Boolean.
		// this.modalSubmit   function to run "ok" click if valid.
	
		var modalCanvasSize = Object.create(Modal);
	
		modalCanvasSize.titleText = "Canvas Size";
	
		modalCanvasSize.innerMarkup = function () {
			return "<div class=\"modal__configure\">\n\t\t\t<div class=\"modal__section\">\n\t\t\t\t<div class=\"modal__section-title\">Current Size</div>\n\t\t\t\t<div class=\"modal__prop modal__prop--text-only\">\n\t\t\t\t\t<span class=\"modal__prop-name modal__prop-name--text-only\">Width:</span>\n\t\t\t\t</div\n\t\t\t\t><div class=\"modal__value modal__value--text-only\">\n\t\t\t\t\t<span class=\"modal__value-name modal__value-name--text-only\"\n\t\t\t\t\t\tdata-modal-canvas-size-current-width >\n\t\t\t\t\t\t" + this.currentCanvasWidth + "</span>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"modal__prop modal__prop--text-only\">\n\t\t\t\t\t<span class=\"modal__prop-name modal__prop-name--text-only\">Height:</span>\n\t\t\t\t</div\n\t\t\t\t><div class=\"modal__value modal__value--text-only\">\n\t\t\t\t\t<span class=\"modal__value-name modal__value-name--text-only\"\n\t\t\t\t\t\tdata-modal-canvas-size-current-height\n\t\t\t\t\t\t\t>" + this.currentCanvasHeight + "</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"modal__section\">\n\t\t\t\t<div class=\"modal__section-title\">New Size</div>\n\t\t\t\t<div class=\"modal__prop\">\n\t\t\t\t\t<span class=\"modal__prop-name\">Width:</span>\n\t\t\t\t</div\n\t\t\t\t><div class=\"modal__value\">\n\t\t\t\t\t<input id=\"canvas-size-width\" class=\"modal__numeric-input\" type=number min=\"0\"\n\t\t\t\t\t\tstep=\"1\" required value=" + this.currentCanvasWidth + "\n\t\t\t\t\t\tdata-modal-canvas-size-new-width>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"modal__prop\">\n\t\t\t\t\t<span class=modal__prop-name>Height:</span>\n\t\t\t\t</div\n\t\t\t\t><div class=\"modal__value\">\n\t\t\t\t\t<input class=\"modal__numeric-input\" type=\"number\" min=\"0\" step=\"1\" required\n\t\t\t\t\t\tvalue=" + this.currentCanvasHeight + "  data-modal-canvas-size-new-height>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"modal__prop\">\n\t\t\t\t\t<span class=modal__prop-name>Anchor:</span>\n\t\t\t\t</div\n\t\t\t\t><div class=\"modal__value modal__canvas-direction-button-container\"\n\t\t\t\t\tdata-canvas-direction-container>\n\t\t\t\t\t<svg class=\"modal__canvas-resize-arrows\" xmlns=\"http://www.w3.org/2000/svg\"\n\t\t\t\t\t\tviewBox=\"0 0 68 68\" >\n\t\t\t\t\t\t<polygon fill=\"#231F20\"\n\t\t\t\t\t\t\tpoints=\"4,4 4,13.15 7.87,9.3 15.66,16.95 17.14,15.54 9.41,\n\t\t\t\t\t\t\t\t7.71 13.05,4\"/>\n\t\t\t\t\t\t<polygon fill=\"#231F20\"\n\t\t\t\t\t\t\tpoints=\"40,8 34,2 28,8 33,8 33,19 35,19 35,8\"/>\n\t\t\t\t\t\t<polygon fill=\"#231F20\"\n\t\t\t\t\t\t\tpoints=\"64,4 55,4 58.85,7.85 51.2,15.62 52.61,17.1 60.37,9.37 64,13\"/>\n\t\t\t\t\t\t<polygon fill=\"#231F20\"\n\t\t\t\t\t\t\tpoints=\"8,27.5 2,33.5 8,39.5 8,35 19,35 19,33 8,33\"/>\n\t\t\t\t\t\t<circle id=\"circle_4_\" fill=\"#231F20\" cx=\"34\" cy=\"34\" r=\"3\"/>\n\t\t\t\t\t\t<polygon fill=\"#231F20\"\n\t\t\t\t\t\t\tpoints=\"60,39.5 66,33.5 60,27.5 60,33 49,33 49,35 60,35\"/>\n\t\t\t\t\t\t<polygon fill=\"#231F20\"\n\t\t\t\t\t\t\tpoints=\"4,64 13.2,64 9.35,60.2 17,52.45 15.59,50.99 7.73,58.72 4,55.1\"/>\n\t\t\t\t\t\t<polygon fill=\"#231F20\"\n\t\t\t\t\t\t\tpoints=\"28,60 34,66 40,60 35,60 35,49 33,49 33,60\"/>\n\t\t\t\t\t\t<polygon fill=\"#231F20\"\n\t\t\t\t\t\t\tpoints=\"64,64 64,54.95 60.22,58.8 52.49,51.15 51.03,52.56 58.77,\n\t\t\t\t\t\t\t60.34 55.15,64\"/>\n\t\t\t\t\t</svg>\n\t\t\t\t\t<button type=button class=\"modal__canvas-direction-button\" tabindex=-1\n\t\t\t\t\t\tdata-canvas-resize-direction=\"left   top\"    ></button\n\t\t\t\t\t><button type=button class=\"modal__canvas-direction-button\" tabindex=-1\n\t\t\t\t\t\tdata-canvas-resize-direction=\"center top\"    ></button\n\t\t\t\t\t><button type=button class=\"modal__canvas-direction-button\" tabindex=-1\n\t\t\t\t\t\tdata-canvas-resize-direction=\"right  top\"    ></button\n\t\t\t\t\t><button type=button class=\"modal__canvas-direction-button\" tabindex=-1\n\t\t\t\t\t\tdata-canvas-resize-direction=\"left   middle\" ></button\n\t\t\t\t\t><button type=button class=\"modal__canvas-direction-button\" tabindex=-1\n\t\t\t\t\t\tdata-canvas-resize-direction=\"center middle\" ></button\n\t\t\t\t\t><button type=button class=\"modal__canvas-direction-button\" tabindex=-1\n\t\t\t\t\t\tdata-canvas-resize-direction=\"right  middle\" ></button\n\t\t\t\t\t><button type=button class=\"modal__canvas-direction-button\" tabindex=-1\n\t\t\t\t\t\tdata-canvas-resize-direction=\"left   bottom\" ></button\n\t\t\t\t\t><button type=button class=\"modal__canvas-direction-button\" tabindex=-1\n\t\t\t\t\t\tdata-canvas-resize-direction=\"center bottom\" ></button\n\t\t\t\t\t><button type=button class=\"modal__canvas-direction-button\" tabindex=-1\n\t\t\t\t\t\tdata-canvas-resize-direction=\"right  bottom\" ></button\n\t\t\t\t></div\n\t\t\t></div\n\t\t></div\n\t\t><div class=modal__confirm>\n\t\t\t<button type=button class=\"modal__button modal-ok\" data-modal-ok>OK</button>\n\t\t\t<button type=button class=\"modal__button modal-cancel\" data-modal-cancel>Cancel</button>\n\t\t</div>\n\t\t<div class=\"modal__error-text\"></div>";
		};
	
		modalCanvasSize.modalInternalBinding = function () {
			var doc = document; // Shortening only :/
			this.resizeIconPositionX = "center";
			this.resizeIconPositionY = "middle";
	
			this.onResizeDirectionButtonClick = this.onResizeDirectionButtonClick.bind(this);
	
			this.resizeDirectionContainer = doc.querySelector("[data-canvas-direction-container]");
			this.resizeDirectionContainer.addEventListener("click", this.onResizeDirectionButtonClick);
	
			// Focus the first input box and select (highlight) its contents.
			// FF doesn"t support select() method.
			// Webkit throws InvalidStateError on setSelectionRange on an input type=number element.
			// https://code.google.com/p/chromium/issues/detail?id=346270
			var firstInput = doc.getElementById("canvas-size-width");
			try {
				firstInput.focus();
				firstInput.setSelectionRange(0, 9999);
			} catch (e) {
				firstInput.select();
			}
		};
	
		modalCanvasSize.modalInternalUnbinding = function () {
			var that = this;
			this.resizeDirectionContainer.removeEventListener("click", that.onResizeDirectionButtonClick);
		};
	
		// Returns true if user input is valid.
		modalCanvasSize.modalValidate = function () {
			var newWidthEl = document.querySelector("[data-modal-canvas-size-new-width]");
			var newHeightEl = document.querySelector("[data-modal-canvas-size-new-height]");
			var newWidth = parseInt(newWidthEl.value);
			var newHeight = parseInt(newHeightEl.value);
			var errorText = void 0;
	
			this.errorEl = document.querySelector(".modal__error-text");
	
			if (typeof newWidth !== "number" || typeof newHeight !== "number" || Number.isNaN(newWidth) || Number.isNaN(newHeight)) {
				errorText = "Oops! Please enter a numeric input value.";
			} else if (newWidth < 3 || newHeight < 3) {
				errorText = "Oops! Canvases must be at least three pixels or larger on each dimension.";
			} else if (newWidth >= 5000 || newHeight >= 5000) {
				errorText = "Whoa Nellie! Please keep it under 5000 pixels on each dimension.";
			}
			if (errorText) {
				this.showError(errorText);
				return false;
			} else {
				this.newWidth = newWidth;
				this.newHeight = newHeight;
				return true;
			}
		};
	
		modalCanvasSize.onResizeDirectionButtonClick = function (e) {
			e.preventDefault();
			e.stopImmediatePropagation();
	
			// Target should be one of the child buttons, split on spaces.
			var positions = e.target.getAttribute("data-canvas-resize-direction");
			positions = positions.split(/\s+/);
	
			// Set the new icon positions.
			// Markup is strictly horizontal value first, then vertical value.
			this.resizeIconPositionX = positions[0];
			this.resizeIconPositionY = positions[1];
	
			// Remove all old positioning classes. This could surely be improved?
			this.resizeDirectionContainer.classList.remove("resize-icon-top", "resize-icon-middle", "resize-icon-bottom", "resize-icon-left", "resize-icon-center", "resize-icon-right");
	
			// And add the new appropriate classes.
			this.resizeDirectionContainer.classList.add("resize-icon-" + this.resizeIconPositionX);
			this.resizeDirectionContainer.classList.add("resize-icon-" + this.resizeIconPositionY);
		};
	
		return modalCanvasSize;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Modal, parseRLEFile, parseBMP) {
	
		// To be added & customized for each unique modal object:
		// this.titleText   html to insert in body of modal
		// this.innerMarkup   html to insert in body of modal
		// this.modalInternalBinding   listeners other than ok/cancel
		// this.modalInternalUnbinding  remove listeners other than ok/cancel
		// this.modalValidate  optional check on click of OK. returns a Boolean.
		// this.modalSubmit   function to run 'ok' click if valid.
	
		var modalOpenPattern = Object.create(Modal);
	
		modalOpenPattern.titleText = "Open Pattern";
	
		modalOpenPattern.innerMarkup = function () {
			return "<div class='modal__open modal__configure'>" + "<div class='modal__open__instructions'>Choose a JSON, RLE, or 1-bit" + " Windows BMP file pattern from your file system." + "</div>" + "</div" + "><div class=modal__confirm>" + "<button type=button class='modal__button modal-ok'" + " data-modal-ok>OK</button>" + "<button type=button class='modal__button modal-cancel' " + "data-modal-cancel>Cancel</button>" + "</div>" + "<div class='modal__open__error-text modal__error-text'></div>" + "<div class=modal__input-file-wrapper>" + "<input class=modal__file-input type=file>" + "</div>";
		};
	
		modalOpenPattern.modalInternalBinding = function () {
			var fileInputEl = document.querySelector(".modal__file-input");
			var errorEl = document.querySelector(".modal__error-text");
	
			this.modalValidateFileInputChoice = this.modalValidateFileInputChoice.bind(this);
			this.modalValidateFileInputContents = this.modalValidateFileInputContents.bind(this);
	
			this.fileInputEl = fileInputEl;
			this.errorEl = errorEl;
	
			// Don't wait until "OK" click to validate the input.
			this.fileInputEl.addEventListener("change", this.modalValidateFileInputChoice);
		};
	
		modalOpenPattern.modalInternalUnbinding = function () {
			this.fileInputEl.removeEventListener("change", this.modalValidateFileInputChoice);
		};
	
		modalOpenPattern.parsedPattern = null;
		modalOpenPattern.isValid = false; // Nothing initially selected.
	
		modalOpenPattern.validateBMP = function (file) {
			var bm = parseBMP(file);
			var errorText = "";
	
			if (bm.iHeader.bitsPerPixel > 1) {
				errorText = "The BMP file can't be read because it has a bit depth of " + "greater than one.";
			} else if (bm.iHeader.compressionMethod > 0) {
				errorText = "Lifey currently only supports uncompressed BMP files.";
			}
			if (errorText) {
				this.parsedPattern = null;
			} else {
				this.parsedPattern = bm;
			}
			return errorText;
		};
	
		modalOpenPattern.readFile = function (file) {
			var fReader = new FileReader();
			var that = this;
			var ext = this.fileExtension;
	
			fReader.onload = function (e) {
				that.modalValidateFileInputContents(e.target.result);
			};
	
			// Read the file differently based on the extension.
			// This kicks off the onload event above.
			if (ext === "JSON" || ext === "RLE") {
				fReader.readAsText(file);
			} else if (ext === "BMP") {
	
				// BMP is binary, read as an Array Buffer.
				fReader.readAsArrayBuffer(file);
			}
		};
	
		// Validity can be set by the file(s) being selected, or the file being (mis)read
		// or parsed. This gets checked on click of "ok" button.
		modalOpenPattern.modalValidate = function () {
			return this.isValid;
		};
	
		modalOpenPattern.modalValidateFileInputContents = function (file) {
			var ext = this.fileExtension;
			var errorText = "";
	
			if (ext === "JSON") {
				try {
					this.parsedPattern = JSON.parse(file);
				} catch (e) {
					errorText = "The file text is not valid JSON." + " Please check the file for a possible syntax error.";
				}
			} else if (ext === "RLE") {
				this.parsedPattern = parseRLEFile(file);
			} else if (ext === "BMP") {
				errorText = this.validateBMP(file);
			}
	
			this.showError(errorText);
			this.isValid = !errorText;
		};
	
		modalOpenPattern.modalValidateFileInputChoice = function () {
			var fileList = this.fileInputEl.files;
			var file = fileList[0];
			var errorText = ""; // Always added, must be a string.
			var fileName = file.name;
			var fileExtension = fileName.split(".").pop().toUpperCase();
			this.fileExtension = fileExtension;
	
			if (!file || fileList.length === 0) {
				errorText = "No file selected.";
			} else if (fileList.length > 1) {
				errorText = "Multiple files selected. Please choose a single file.";
			} else if (fileExtension !== "JSON" && fileExtension !== "BMP" && fileExtension !== "RLE") {
				errorText = "The file name should end with a dot, followed by either â€œjsonâ€," + " â€œrleâ€, or â€œbmpâ€.";
			}
	
			if (errorText) {
				this.parsedPattern = null;
			} else {
				this.readFile(file); // Kicks off a second round of validation.
			}
	
			// Always "show" the error even if it's an empty string, so that a file input
			// correction erases any previous error messages.
			this.showError(errorText);
			this.isValid = !errorText;
		};
	
		return modalOpenPattern;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/**
	 * Parse RLE to JSON
	 *
	 * Parses "run-length-encoded" (.rle) files used for storing
	 * cellular automata patterns. Written as AMD module.
	 *
	 * By Alex Bell |  MIT License
	 *
	 * @returns {
	 *     name: String,
	 *     comments: String,
	 *     author: String,
	 *     coordinates: [Integer, Integer],
	 *     rule: String,
	 *     width: Integer,
	 *     height: Integer,
	 *     pattern: str
	 *  }
	 *
	 * Based on the very basic syntax/grammar outline here
	 * http://www.mirekw.com/ca/ca_files_formats.html
	 *
	 *   b = a dead cell
	 *   o = a live cell
	 *   $ = end of a line of the pattern
	 *
	 *   #N Beehive at beehive
	 *   #C A simple 12-cell still life composed of two beehive.
	 *   #C www.conwaylife.com/wiki/index.php?title=Beehive_at_beehive
	 *   #O ook "The Librarian"@unseen.edu Fri Apr 30 19:38:52 1999
	 *   #R -22 -57 (this is the offset from the top left.)
	 *   x = 6, y = 6, rule = 23/3
	 *   4bob$3bobo$3bobo$b2obob$o2bo2b$b2o!
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	
		return function (str) {
			var ret = Object.create(null);
	
			if (!str) {
				return;
			} // Stay out of trouble.
	
			var pos = 0;
			var chrctr = void 0;
			var inComment = false;
			var currentTerm = void 0; // Can be "width", "height", or "rule"
	
			ret.name = ""; // These are the really the only two properties certain to be included.
			ret.pattern = "";
	
			var isSpace = function isSpace(c) {
				return c === " " || // Space
				c === "\t"; // Horizontal tab
			};
	
			var isNewLine = function isNewLine(c) {
				return c === "\n" || // New line
				c === "\f" || // Form feed
				c === "\r"; // Carriage return
			};
	
			// http://jsperf.com/isdigittest/5
			var isDigit = function isDigit(n) {
				return Boolean([true, true, true, true, true, true, true, true, true, true][n]);
			};
	
			var stripTrailingSpaces = function stripTrailingSpaces(str) {
				while (isSpace(str[str.length - 1])) {
					str = str.substring(0, str.length - 2);
				}
				return str;
			};
	
			var createEmptyPropIfNone = function createEmptyPropIfNone(str) {
				if (!ret[str]) {
					ret[str] = "";
				}
			};
	
			while (true) {
				chrctr = str[pos];
	
				// If string has no length, or we've hit the exclamation point EOF marker,
				// or end of string reached.
				if (!chrctr || chrctr === "!") {
					return ret;
				}
	
				// Determine if entering a comment
				if (chrctr === "#") {
					if (str[pos + 1] === "N" || str[pos + 1] === "n") {
						inComment = "name";
					} else if (str[pos + 1] === "C" || str[pos + 1] === "c") {
						inComment = "comments";
						createEmptyPropIfNone("comments");
					} else if (str[pos + 1] === "O" || str[pos + 1] === "o") {
						inComment = "author";
						createEmptyPropIfNone("author");
					} else if (str[pos + 1] === "R") {
						inComment = "coordinates";
						createEmptyPropIfNone("coordinates");
					}
					pos = pos + 2;
					continue;
	
					// Inside a comment
				} else if (inComment) {
	
					// Bail out of comment on newline.
					if (isNewLine(chrctr)) {
	
						// Remove trailing spaces from a comment line.
						ret[inComment] = stripTrailingSpaces(ret[inComment]);
	
						if (inComment === "coordinates") {
							ret.coordinates = ret.coordinates.split(" ");
							ret.coordinates[0] = parseInt(ret.coordinates[0], 10); // The x
							ret.coordinates[1] = parseInt(ret.coordinates[1], 10); // The y
						}
						inComment = false;
	
						// Ignore leading spaces and tabcharacters inside a comment if
						// the corresponding property is currently an empty string.
					} else if (isSpace(chrctr) && ret[inComment] === "") {
	
						// Do nothing inside here. Do Not remove.
	
						// The coordinates string should be only digits, hyphens, spaces.
						// Skip over anything else like letters or punctuation.
					} else if (inComment === "coordinates" && !isSpace(chrctr) && !isDigit(chrctr) && chrctr !== "-") {
						pos += 1;
						continue;
					} else {
	
						// The general case: add the character to the comment.
						ret[inComment] += chrctr;
					}
	
					// Not in a comment from here on down.
					// Determine if entering a property
				} else if (chrctr === "x") {
					currentTerm = "width";
					createEmptyPropIfNone("width");
				} else if (chrctr === "y") {
					currentTerm = "height";
					createEmptyPropIfNone("height");
				} else if (str.substring(pos, pos + 4) === "rule") {
					currentTerm = "rule";
					createEmptyPropIfNone("rule");
	
					// Reset currentTerm to empty on commas or newlines
				} else if (chrctr === "," || isNewLine(chrctr)) {
					currentTerm = "";
	
					// Convert to number
					if (ret.width && ret.height) {
						ret.width = parseInt(ret.width);
						ret.height = parseInt(ret.height);
					}
				} else if (currentTerm) {
	
					// Width, height, and rule all accept any digit.
					if (isDigit(chrctr)) {
						ret[currentTerm] += chrctr;
	
						// "rule" additionally accepts a slash
					} else if (currentTerm === "rule" && chrctr === "/") {
						ret[currentTerm] += "/";
					}
	
					// Not in a comment, and not in currentTerm,
					// which means we've reached the actual pattern.
				} else if (isDigit(chrctr) || chrctr === "b" || chrctr === "o" || chrctr === "$") {
					ret.pattern += chrctr;
				}
	
				pos += 1;
			} // End of big while loop.
		};
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	
		/**
	  * @param {Buffer} buffer (from FileReader)
	  * @returns {Object} with image properties
	  */
		return function (buffer) {
			var dataV = new DataView(buffer);
			var bm = Object.create(null);
	
			// Omit for brevity:
			// let decoder = new TextDecoder( "utf-8" );
	
			bm.fHeader = Object.create(null);
	
			// Much of this could be omitted for brevity, but it's useful for
			// reference and debugging.
	
			// Typically "BM" for Windows 3, 95, NT +
			// Ancient unsupported entries include: "BA", "CI", "CP", "IC", "PT".
			// bm.fHeader.type = decoder.decode( new DataView( buffer, 0, 2 ) );
	
			// The file size in bytes
			// bm.fHeader.byteSize =         dataV.getUint32( 2, true );
	
			// Reserved, depends on the application
			// bm.fHeader.reserved1 =        dataV.getUint16( 6, true );
	
			// Reserved, depends on the application
			// bm.fHeader.reserved2 =        dataV.getUint16( 8, true );
	
			// Offset of the byte where the pixel array starts
			bm.fHeader.offsetToPixArray = dataV.getUint32(10, true);
	
			bm.iHeader = Object.create(null);
	
			// The size of this header, varies with format version #
			// e.g. V2 = 12; V3 = 40; V4 = 108; V5 = 124
			// bm.iHeader.headerSize =        dataV.getUint32( 14, true );
	
			// The bitmap width in pixels (integer).
			bm.width = dataV.getUint32(18, true);
	
			// The bitmap height in pixels (integer).
			bm.height = dataV.getUint32(22, true);
	
			// Number of color planes used (set to 1).
			// bm.iHeader.colorPlanes =       dataV.getUint16( 26, true );
	
			// Number of bits per pixel. Typically: 1, 4, 8, 16, 24 or 32.
			bm.iHeader.bitsPerPixel = dataV.getUint16(28, true);
	
			// The compression method being used. 0 means uncompressed,
			// which is currently the only value supported in the validator.
			bm.iHeader.compressionMethod = dataV.getUint32(30, true);
	
			// Image size of raw bitmap data (not file size).
			// bm.iHeader.imageSize =         dataV.getUint32( 34, true );
	
			// Irrelevant in this context.
			// bm.iHeader.pixPerMeterX =      dataV.getUint32( 38, true );
			// bm.iHeader.pixPerMeterY =      dataV.getUint32( 42, true );
	
			// Number of colors in the palette. Should be "0" for 1 bit.
			// bm.iHeader.usedColors =        dataV.getUint32( 46, true );
	
			// Number of important colors used
			// bm.iHeader.importantColors =   dataV.getUint32( 50, true );
	
			// Stride is the number of bytes in a row. Stride must be a multiple of 4.
			bm.stride = Math.ceil(bm.iHeader.bitsPerPixel * bm.width / 32) * 4;
	
			// Total number of pixels in the image
			bm.pixels = new Uint8Array(bm.width * bm.height); // Initially all zeros
	
			var offset = bm.fHeader.offsetToPixArray;
			var indent = void 0,
			    byteAddress = void 0,
			    bitAddress = void 0,
			    byteVal = void 0,
			    bitVal = void 0;
	
			// Outer loop iterates image rows
			for (var y = 0; y < bm.height; y += 1) {
				indent = bm.stride * y;
	
				// Inner loop iterates image columns
				for (var x = 0; x < bm.width; x += 1) {
					byteAddress = Math.floor(x / 8);
					bitAddress = x % 8;
					byteVal = dataV.getUint8(offset + indent + byteAddress, true);
					byteVal = byteVal.toString(2); // Convert to base 2
	
					// Trick to pad left with zeros to 8 digits
					byteVal = ("00000000" + byteVal).substring(byteVal.length);
					bitVal = byteVal[bitAddress];
	
					// BMP pixels start at the bottom left, so reverse the row order
					bm.pixels[(bm.height - 1 - y) * bm.width + x] = bitVal;
				}
			}
	
			return bm;
		};
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Modal) {
	
		// To be added & customized for each unique modal objects:
		// this.titleText   html to insert in body of modal
		// this.innerMarkup   html to insert in body of modal
		// this.modalInternalBinding   listeners other than ok/cancel
		// this.modalInternalUnbinding  remove listeners other than ok/cancel
		// this.modalValidate  optional check on click of OK. returns a Boolean.
		// this.modalSubmit   function to run 'ok' click if valid.
	
		var modalSavePattern = Object.create(Modal);
	
		modalSavePattern.titleText = "Save As";
	
		modalSavePattern.innerMarkup = function () {
			return "<div class='modal__configure modal__configure--save-as'>" + "<div class='modal__save-pattern-option'>Format:</div>" + "<div class='modal__save-pattern-option-input-wrapper'>" + "<select class=modal__save-pattern-option-input name=fileformat" + " data-modal-save-file-format>" + "<option value='json' selected>JavaScript Object Notation (.json)</option>" + "<option value='rle'>Run Length Encoded (.rle)</option>" + "</select>" + "</div>" + "<div class=modal__save-pattern-option>Pattern Name:</div>" + "<div class=modal__save-pattern-option-input-wrapper>" + "<input type=text class=modal__save-pattern-option-input" + " data-modal-save-pattern-name>" + "</div>" + "<div class=modal__save-pattern-option>Author:</div>" + "<div class=modal__save-pattern-option-input-wrapper>" + "<input type=text class=modal__save-pattern-option-input" + " data-modal-save-pattern-author>" + "</div>" + "<div class=modal__error-text></div>" + "</div>" + "<div class='modal__confirm modal__confirm--bottom-corner'>" + "<button type=button class='modal__button modal-cancel modal-cancel--save-as'" + "data-modal-cancel>Cancel</button>" + "<button type=button class='modal__button modal-ok modal-ok--save-as'" + "data-modal-ok >Save</button>" + "</div>";
		};
	
		return modalSavePattern;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Modal) {
	
		// To be added & customized for each unique modal object:
		// this.titleText   html to insert in body of modal.
		// this.innerMarkup   html to insert in body of modal.
		// this.modalInternalBinding   (optional) listeners other than ok/cancel.
		// this.modalInternalUnbinding  (optional) remove listeners other than ok/cancel.
		// this.modalValidate  (optional) check on click of OK. returns a Boolean.
		// this.modalSubmit   function to run "ok" click if valid.
	
		var modalSharePattern = Object.create(Modal);
	
		modalSharePattern.titleText = "Share Pattern";
	
		modalSharePattern.innerMarkup = function () {
			return "" + "<div class='modal__configure modal__share__configure'>" + "<div class='modal__section-title--share'>" + "<span class=pattern-fits-in-url></span>" + "</div>" + "</div>" + "<div class=modal__confirm>" + "<button type=button class='modal__button modal-ok' data-modal-ok>OK</button>" + "</div>" + "<div class=modal__shareable-url data-modal-shareable-url></div";
		};
	
		return modalSharePattern;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/**  ---- Parse RLE pixel string ----
	 *
	 *	 Based on the syntax outline at:
	 *	 http://www.mirekw.com/ca/ca_files_formats.html
	 *
	 *   b = a dead cell
	 *   o = a live cell
	 *   $ = end of a line of the pattern
	 *
	 *   4bob$3bobo$3bobo$b2obob$o2bo2b$b2o!
	 *
	 *	Returns a uInt8 Array of pixel data with 0 = dead, 1 = live
	 *
	 * @param {String} str
	 * @param {Number} width
	 * @param {Number} height
	 * @returns {uInt8 Array}
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ut) {
	
		// Currently needed just for Intern to allow block-scoping.
		// Consider removing in build.
		"use strict";
	
		return function (str, width, height) {
			width = width || 0;
			height = height || 0;
			var chrctr = void 0;
			var pos = 0;
			var runCount = ""; // Concatenated character by character
			var runCountInteger = void 0;
			var currentX = 0;
			var currentY = 0;
			var dataArray = new Int8Array(width * height); // All zeros initially
	
			if (!str || !width || !height) {
				return; // Stay out of loop.
			}
	
			// Loop through each character in the string.
			while (true) {
				chrctr = str[pos];
	
				// If end of string reached, or exclamation point EOF marker.
				if (!chrctr || chrctr === "!") {
					return dataArray; // Main return path
				} else if (ut.isDigit(chrctr)) {
					runCount += chrctr;
				} else if (chrctr === "b" || chrctr === "o") {
					runCountInteger = parseInt(runCount) || 1;
	
					// Don't bother setting empty cells on the typed array,
					// because it's pre-populated with all zeroes.
					if (chrctr === "o") {
						for (var i = 0; i < runCountInteger; i += 1) {
							dataArray[currentY * width + currentX + i] = 1;
						}
					}
	
					// Advance currentX (whether it's a "b" or an "o")
					currentX += runCountInteger;
					runCount = ""; // Reset
				} else if (chrctr === "$") {
	
					// End of this row, and possibly the next rows, etc.
					// Basically treat runCount $s as "newlines" in the grid.
					runCountInteger = parseInt(runCount) || 1;
	
					currentX = 0;
					currentY += runCountInteger;
					runCount = "";
				}
	
				pos += 1;
			}
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/**  ---- Convert Pattern Object to RLE file string ----
	 *
	 *	 Based on the syntax outline at:
	 *	 http://www.mirekw.com/ca/ca_files_formats.html
	 *
	 *   #N Beehive at beehive
	 *   #C A simple 12-cell still life composed of two beehive.
	 *   #C www.conwaylife.com/wiki/index.php?title=Beehive_at_beehive
	 *   #O ook "The Librarian"@unseen.edu Fri Apr 30 19:38:52 1999
	 *   #R -22 -57
	 *   x = 6, y = 6, rule = 23/3
	 *   4bob$3bobo$3bobo$b2obob$o2bo2b$b2o!
	 *
	 *   TO DO: Integrate #R value with offsetX and offsetY? It's unclear to me
	 *   right now what negative #R values here are relative to.
	 *
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	
	  return function (pat) {
	    var retStr = "";
	
	    if (pat.name) {
	      retStr += "#N " + pat.name + "\n";
	    }
	    if (pat.author) {
	      retStr += "#O " + pat.author + "\n";
	    }
	    retStr += "x = " + pat.width + ", y=" + pat.height + ", rule = B3/S23\n";
	    retStr += pat.pattern + "!\n";
	
	    return retStr;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/**
	 * Fn dataArrayToRLE
	 * @returns {object}  returns object with properties
	 *	 pattern {string},
	 *	 width {integer},
	 *	 height {integer},
	 *   minCanvasX {integer},
	 *   minCanvasY {integer},
	 *   offsetX {integer},
	 *   offsetY {integer}
	 */
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	
		// Currently needed just for Intern to allow block-scoping.
		"use strict";
	
		return function (dataArray, canvasWidth, canvasHeight) {
			var len = dataArray.length;
			if (len !== canvasWidth * canvasHeight) {
				console.log("dataArray doesn't match supplied canvas dimensions.");
				return false;
			}
	
			var posTopMost = 0; // Start at beginning.
			for (; posTopMost < len; posTopMost += 1) {
				if (dataArray[posTopMost] === 1) {
					break; // Exit at first active cell.
				}
			}
	
			var posBottomMost = len - 1; // Start at end.
			for (; posBottomMost > 0; posBottomMost -= 1) {
				if (dataArray[posBottomMost] === 1) {
					break;
				}
			}
	
			// Array position of leftmost active. Start all the way right and move left.
			var posLeftMost = canvasWidth - 1;
			for (var i = 0; i < len; i += 1) {
				if (dataArray[i] === 1 && i % canvasWidth < posLeftMost % canvasWidth) {
					posLeftMost = i; // Must go through the full loop.
				}
			}
	
			// Array position of rightmost active. Start all the way left and move right.
			var posRightMost = 0;
			for (var _i = 0; _i < len; _i += 1) {
				if (dataArray[_i] === 1 && _i % canvasWidth > posRightMost % canvasWidth) {
					posRightMost = _i; // Must go through the full loop.
				}
			}
	
			var patternWidth = posRightMost % canvasWidth - posLeftMost % canvasWidth + 1;
			var patternHeight = Math.floor(posBottomMost / canvasWidth) - Math.floor(posTopMost / canvasWidth) + 1;
			var offsetX = posLeftMost % canvasWidth;
			var offsetY = Math.floor(posTopMost / canvasWidth);
	
			var croppedDataArray = cropArray(dataArray, canvasWidth, canvasHeight, patternWidth, patternHeight, offsetX, offsetY);
	
			var ret = Object.create(null);
			ret.pattern = encodeArrayAsRLEString(croppedDataArray, patternWidth);
			ret.width = patternWidth;
			ret.height = patternHeight;
	
			if (patternWidth < canvasWidth) {
				ret.offsetX = offsetX;
				ret.minCanvasX = canvasWidth;
			}
			if (patternHeight < canvasHeight) {
				ret.offsetY = offsetY;
				ret.minCanvasY = canvasHeight;
			}
	
			// Handle the "completely empty canvas" case.
			// Never return a negative width and height.
			if (posTopMost === len) {
				ret.width = ret.height = ret.offsetX = ret.offsetY = 0;
			}
	
			return ret;
		};
	
		/**
	  *	Returns a cropped data Array.
	  *
	  *  offsetX and offsetY values are from top left.
	  */
		function cropArray(arr, currWidth, currHeight, cropWidth, cropHeight, offsetX, offsetY) {
			var newDataArray = new Int8Array(cropWidth * cropHeight);
	
			// Loop through all of the newDataArray,
			// getting values from the old DataArray.
			for (var i = 0; i < cropHeight; i += 1) {
				for (var j = 0; j < cropWidth; j += 1) {
					newDataArray[i * cropWidth + j] = arr[(i + offsetY) * currWidth + j + offsetX];
				}
			}
			return newDataArray;
		}
	
		function encodeArrayAsRLEString(dataArr, canvasWidth) {
			var retStr = "";
			var currentChar = void 0,
			    previousChar = void 0;
			var previousCharCount = 0;
			var previousEndRowCount = 0;
	
			var len = dataArr.length;
	
			for (var i = 0; i < len; i += 1) {
				currentChar = dataArr[i] ? "o" : "b";
	
				// For tailing characters at the end of a row:
				// bb do nothing.
				// bo write number of repeats, then "b", then "o".
				// ob write number of repeats, then "o".
				// oo write number of repeats + 1, then "o".
	
				// If on the last cell of a row.
				if (i > 0 && (i + 1) % canvasWidth === 0) {
					if (currentChar === "o") {
	
						// First, if there are any accumulated end-of-lines, print them
						// and reset the blank row counter.
						if (previousEndRowCount) {
							if (previousEndRowCount > 1) {
								retStr += previousEndRowCount;
							}
							retStr += "$";
							previousEndRowCount = 0;
						}
	
						if (previousChar === "o") {
	
							// INCREMENT
							previousCharCount += 1;
							retStr += previousCharCount;
						} else if (previousChar === "b") {
							if (previousCharCount > 1) {
								retStr += previousCharCount;
							}
							retStr += "b";
						}
						retStr = retStr + "o";
					} else if (currentChar === "b") {
						if (previousChar === "o") {
							if (previousCharCount > 1) {
								retStr += previousCharCount;
							}
							retStr += previousChar;
						}
					}
	
					// Increment the row count, unless we're at the very end of the entire array.
					// TO DO: Consider adding the exclamation mark EOF? Possibly unnecessary in JSON.
					if (i !== len - 1) {
						previousEndRowCount += 1;
						previousChar = undefined;
						previousCharCount = 0;
					}
	
					// INCREMENT, THE GENERAL CASE.
				} else if (currentChar === previousChar) {
					previousCharCount += 1;
					continue;
	
					// WRITE
				} else {
	
					// We're either:
					// 	- at the beginning of a new row with any value.
					//  - in the middle of a row that has live cells on it, and at
					//    a new character or a different character.
	
					// Write to the output string and reset the counter.
	
					// If reached an active cell and there is are any accumulated
					// end-of-lines, print them first and reset the blank row counter.
					if (currentChar === "o" && previousEndRowCount) {
						if (previousEndRowCount > 1) {
							retStr += previousEndRowCount;
						}
						retStr += "$";
						previousEndRowCount = 0;
					}
	
					if (previousCharCount > 1) {
						retStr += previousCharCount;
					}
					if (previousChar) {
						retStr += previousChar;
					}
	
					// Reset for next iteration of loop.
					previousChar = currentChar;
					previousCharCount = 1;
				}
			}
	
			return retStr;
		}
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	// Adapted and improved from
	// http://thiscouldbebetter.neocities.org/texteditor.html
	
	// If this presents problems in the future consider migrating up to:
	// https://github.com/eligrey/FileSaver.js
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ut) {
		var objURL = void 0;
	
		function destroyClickedElement(event) {
			event.target.removeEventListener("click", destroyClickedElement);
			document.body.removeChild(event.target);
		}
	
		return function (textStr, fileName) {
	
			// Any old reference ought to be released.
			// https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
			if (objURL) {
				window.URL.revokeObjectURL(objURL);
			}
			var textFileAsBlob = new Blob([textStr], { type: "text/plain" });
			var downloadLink = document.createElement("a");
			downloadLink.download = fileName;
			objURL = window.URL.createObjectURL(textFileAsBlob);
			downloadLink.href = objURL;
	
			// Chrome allows the link to be clicked without actually adding it to the DOM.
			// Firefox requires the link to be added to the DOM before it can be clicked.
			if (!(navigator && navigator.vendor && navigator.vendor === "Google Inc.")) {
				downloadLink.addEventListener("click", destroyClickedElement);
				downloadLink.style.display = "none";
				document.body.appendChild(downloadLink);
			}
	
			downloadLink.click();
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/*! Hammer.JS - v2.0.7 - 2016-04-22
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2016 Jorik Tangelder;
	 * Licensed under the MIT license */
	(function (window, document, exportName, undefined) {
	    'use strict';
	
	    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
	    var TEST_ELEMENT = document.createElement('div');
	
	    var TYPE_FUNCTION = 'function';
	
	    var round = Math.round;
	    var abs = Math.abs;
	    var now = Date.now;
	
	    /**
	     * set a timeout with a given scope
	     * @param {Function} fn
	     * @param {Number} timeout
	     * @param {Object} context
	     * @returns {number}
	     */
	    function setTimeoutContext(fn, timeout, context) {
	        return setTimeout(bindFn(fn, context), timeout);
	    }
	
	    /**
	     * if the argument is an array, we want to execute the fn on each entry
	     * if it aint an array we don't want to do a thing.
	     * this is used by all the methods that accept a single and array argument.
	     * @param {*|Array} arg
	     * @param {String} fn
	     * @param {Object} [context]
	     * @returns {Boolean}
	     */
	    function invokeArrayArg(arg, fn, context) {
	        if (Array.isArray(arg)) {
	            each(arg, context[fn], context);
	            return true;
	        }
	        return false;
	    }
	
	    /**
	     * walk objects and arrays
	     * @param {Object} obj
	     * @param {Function} iterator
	     * @param {Object} context
	     */
	    function each(obj, iterator, context) {
	        var i;
	
	        if (!obj) {
	            return;
	        }
	
	        if (obj.forEach) {
	            obj.forEach(iterator, context);
	        } else if (obj.length !== undefined) {
	            i = 0;
	            while (i < obj.length) {
	                iterator.call(context, obj[i], i, obj);
	                i++;
	            }
	        } else {
	            for (i in obj) {
	                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	            }
	        }
	    }
	
	    /**
	     * wrap a method with a deprecation warning and stack trace
	     * @param {Function} method
	     * @param {String} name
	     * @param {String} message
	     * @returns {Function} A new function wrapping the supplied method.
	     */
	    function deprecate(method, name, message) {
	        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
	        return function () {
	            var e = new Error('get-stack-trace');
	            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
	
	            var log = window.console && (window.console.warn || window.console.log);
	            if (log) {
	                log.call(window.console, deprecationMessage, stack);
	            }
	            return method.apply(this, arguments);
	        };
	    }
	
	    /**
	     * extend object.
	     * means that properties in dest will be overwritten by the ones in src.
	     * @param {Object} target
	     * @param {...Object} objects_to_assign
	     * @returns {Object} target
	     */
	    var assign;
	    if (typeof Object.assign !== 'function') {
	        assign = function assign(target) {
	            if (target === undefined || target === null) {
	                throw new TypeError('Cannot convert undefined or null to object');
	            }
	
	            var output = Object(target);
	            for (var index = 1; index < arguments.length; index++) {
	                var source = arguments[index];
	                if (source !== undefined && source !== null) {
	                    for (var nextKey in source) {
	                        if (source.hasOwnProperty(nextKey)) {
	                            output[nextKey] = source[nextKey];
	                        }
	                    }
	                }
	            }
	            return output;
	        };
	    } else {
	        assign = Object.assign;
	    }
	
	    /**
	     * extend object.
	     * means that properties in dest will be overwritten by the ones in src.
	     * @param {Object} dest
	     * @param {Object} src
	     * @param {Boolean} [merge=false]
	     * @returns {Object} dest
	     */
	    var extend = deprecate(function extend(dest, src, merge) {
	        var keys = Object.keys(src);
	        var i = 0;
	        while (i < keys.length) {
	            if (!merge || merge && dest[keys[i]] === undefined) {
	                dest[keys[i]] = src[keys[i]];
	            }
	            i++;
	        }
	        return dest;
	    }, 'extend', 'Use `assign`.');
	
	    /**
	     * merge the values from src in the dest.
	     * means that properties that exist in dest will not be overwritten by src
	     * @param {Object} dest
	     * @param {Object} src
	     * @returns {Object} dest
	     */
	    var merge = deprecate(function merge(dest, src) {
	        return extend(dest, src, true);
	    }, 'merge', 'Use `assign`.');
	
	    /**
	     * simple class inheritance
	     * @param {Function} child
	     * @param {Function} base
	     * @param {Object} [properties]
	     */
	    function inherit(child, base, properties) {
	        var baseP = base.prototype,
	            childP;
	
	        childP = child.prototype = Object.create(baseP);
	        childP.constructor = child;
	        childP._super = baseP;
	
	        if (properties) {
	            assign(childP, properties);
	        }
	    }
	
	    /**
	     * simple function bind
	     * @param {Function} fn
	     * @param {Object} context
	     * @returns {Function}
	     */
	    function bindFn(fn, context) {
	        return function boundFn() {
	            return fn.apply(context, arguments);
	        };
	    }
	
	    /**
	     * let a boolean value also be a function that must return a boolean
	     * this first item in args will be used as the context
	     * @param {Boolean|Function} val
	     * @param {Array} [args]
	     * @returns {Boolean}
	     */
	    function boolOrFn(val, args) {
	        if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == TYPE_FUNCTION) {
	            return val.apply(args ? args[0] || undefined : undefined, args);
	        }
	        return val;
	    }
	
	    /**
	     * use the val2 when val1 is undefined
	     * @param {*} val1
	     * @param {*} val2
	     * @returns {*}
	     */
	    function ifUndefined(val1, val2) {
	        return val1 === undefined ? val2 : val1;
	    }
	
	    /**
	     * addEventListener with multiple events at once
	     * @param {EventTarget} target
	     * @param {String} types
	     * @param {Function} handler
	     */
	    function addEventListeners(target, types, handler) {
	        each(splitStr(types), function (type) {
	            target.addEventListener(type, handler, false);
	        });
	    }
	
	    /**
	     * removeEventListener with multiple events at once
	     * @param {EventTarget} target
	     * @param {String} types
	     * @param {Function} handler
	     */
	    function removeEventListeners(target, types, handler) {
	        each(splitStr(types), function (type) {
	            target.removeEventListener(type, handler, false);
	        });
	    }
	
	    /**
	     * find if a node is in the given parent
	     * @method hasParent
	     * @param {HTMLElement} node
	     * @param {HTMLElement} parent
	     * @return {Boolean} found
	     */
	    function hasParent(node, parent) {
	        while (node) {
	            if (node == parent) {
	                return true;
	            }
	            node = node.parentNode;
	        }
	        return false;
	    }
	
	    /**
	     * small indexOf wrapper
	     * @param {String} str
	     * @param {String} find
	     * @returns {Boolean} found
	     */
	    function inStr(str, find) {
	        return str.indexOf(find) > -1;
	    }
	
	    /**
	     * split string on whitespace
	     * @param {String} str
	     * @returns {Array} words
	     */
	    function splitStr(str) {
	        return str.trim().split(/\s+/g);
	    }
	
	    /**
	     * find if a array contains the object using indexOf or a simple polyFill
	     * @param {Array} src
	     * @param {String} find
	     * @param {String} [findByKey]
	     * @return {Boolean|Number} false when not found, or the index
	     */
	    function inArray(src, find, findByKey) {
	        if (src.indexOf && !findByKey) {
	            return src.indexOf(find);
	        } else {
	            var i = 0;
	            while (i < src.length) {
	                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
	                    return i;
	                }
	                i++;
	            }
	            return -1;
	        }
	    }
	
	    /**
	     * convert array-like objects to real arrays
	     * @param {Object} obj
	     * @returns {Array}
	     */
	    function toArray(obj) {
	        return Array.prototype.slice.call(obj, 0);
	    }
	
	    /**
	     * unique array with objects based on a key (like 'id') or just by the array's value
	     * @param {Array} src [{id:1},{id:2},{id:1}]
	     * @param {String} [key]
	     * @param {Boolean} [sort=False]
	     * @returns {Array} [{id:1},{id:2}]
	     */
	    function uniqueArray(src, key, sort) {
	        var results = [];
	        var values = [];
	        var i = 0;
	
	        while (i < src.length) {
	            var val = key ? src[i][key] : src[i];
	            if (inArray(values, val) < 0) {
	                results.push(src[i]);
	            }
	            values[i] = val;
	            i++;
	        }
	
	        if (sort) {
	            if (!key) {
	                results = results.sort();
	            } else {
	                results = results.sort(function sortUniqueArray(a, b) {
	                    return a[key] > b[key];
	                });
	            }
	        }
	
	        return results;
	    }
	
	    /**
	     * get the prefixed property
	     * @param {Object} obj
	     * @param {String} property
	     * @returns {String|Undefined} prefixed
	     */
	    function prefixed(obj, property) {
	        var prefix, prop;
	        var camelProp = property[0].toUpperCase() + property.slice(1);
	
	        var i = 0;
	        while (i < VENDOR_PREFIXES.length) {
	            prefix = VENDOR_PREFIXES[i];
	            prop = prefix ? prefix + camelProp : property;
	
	            if (prop in obj) {
	                return prop;
	            }
	            i++;
	        }
	        return undefined;
	    }
	
	    /**
	     * get a unique id
	     * @returns {number} uniqueId
	     */
	    var _uniqueId = 1;
	    function uniqueId() {
	        return _uniqueId++;
	    }
	
	    /**
	     * get the window object of an element
	     * @param {HTMLElement} element
	     * @returns {DocumentView|Window}
	     */
	    function getWindowForElement(element) {
	        var doc = element.ownerDocument || element;
	        return doc.defaultView || doc.parentWindow || window;
	    }
	
	    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
	
	    var SUPPORT_TOUCH = 'ontouchstart' in window;
	    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
	
	    var INPUT_TYPE_TOUCH = 'touch';
	    var INPUT_TYPE_PEN = 'pen';
	    var INPUT_TYPE_MOUSE = 'mouse';
	    var INPUT_TYPE_KINECT = 'kinect';
	
	    var COMPUTE_INTERVAL = 25;
	
	    var INPUT_START = 1;
	    var INPUT_MOVE = 2;
	    var INPUT_END = 4;
	    var INPUT_CANCEL = 8;
	
	    var DIRECTION_NONE = 1;
	    var DIRECTION_LEFT = 2;
	    var DIRECTION_RIGHT = 4;
	    var DIRECTION_UP = 8;
	    var DIRECTION_DOWN = 16;
	
	    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
	
	    var PROPS_XY = ['x', 'y'];
	    var PROPS_CLIENT_XY = ['clientX', 'clientY'];
	
	    /**
	     * create new input type manager
	     * @param {Manager} manager
	     * @param {Function} callback
	     * @returns {Input}
	     * @constructor
	     */
	    function Input(manager, callback) {
	        var self = this;
	        this.manager = manager;
	        this.callback = callback;
	        this.element = manager.element;
	        this.target = manager.options.inputTarget;
	
	        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	        // so when disabled the input events are completely bypassed.
	        this.domHandler = function (ev) {
	            if (boolOrFn(manager.options.enable, [manager])) {
	                self.handler(ev);
	            }
	        };
	
	        this.init();
	    }
	
	    Input.prototype = {
	        /**
	         * should handle the inputEvent data and trigger the callback
	         * @virtual
	         */
	        handler: function handler() {},
	
	        /**
	         * bind the events
	         */
	        init: function init() {
	            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	        },
	
	        /**
	         * unbind the events
	         */
	        destroy: function destroy() {
	            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	        }
	    };
	
	    /**
	     * create new input type manager
	     * called by the Manager constructor
	     * @param {Hammer} manager
	     * @returns {Input}
	     */
	    function createInputInstance(manager) {
	        var Type;
	        var inputClass = manager.options.inputClass;
	
	        if (inputClass) {
	            Type = inputClass;
	        } else if (SUPPORT_POINTER_EVENTS) {
	            Type = PointerEventInput;
	        } else if (SUPPORT_ONLY_TOUCH) {
	            Type = TouchInput;
	        } else if (!SUPPORT_TOUCH) {
	            Type = MouseInput;
	        } else {
	            Type = TouchMouseInput;
	        }
	        return new Type(manager, inputHandler);
	    }
	
	    /**
	     * handle input events
	     * @param {Manager} manager
	     * @param {String} eventType
	     * @param {Object} input
	     */
	    function inputHandler(manager, eventType, input) {
	        var pointersLen = input.pointers.length;
	        var changedPointersLen = input.changedPointers.length;
	        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
	        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
	
	        input.isFirst = !!isFirst;
	        input.isFinal = !!isFinal;
	
	        if (isFirst) {
	            manager.session = {};
	        }
	
	        // source event is the normalized value of the domEvents
	        // like 'touchstart, mouseup, pointerdown'
	        input.eventType = eventType;
	
	        // compute scale, rotation etc
	        computeInputData(manager, input);
	
	        // emit secret event
	        manager.emit('hammer.input', input);
	
	        manager.recognize(input);
	        manager.session.prevInput = input;
	    }
	
	    /**
	     * extend the data with some usable properties like scale, rotate, velocity etc
	     * @param {Object} manager
	     * @param {Object} input
	     */
	    function computeInputData(manager, input) {
	        var session = manager.session;
	        var pointers = input.pointers;
	        var pointersLength = pointers.length;
	
	        // store the first input to calculate the distance and direction
	        if (!session.firstInput) {
	            session.firstInput = simpleCloneInputData(input);
	        }
	
	        // to compute scale and rotation we need to store the multiple touches
	        if (pointersLength > 1 && !session.firstMultiple) {
	            session.firstMultiple = simpleCloneInputData(input);
	        } else if (pointersLength === 1) {
	            session.firstMultiple = false;
	        }
	
	        var firstInput = session.firstInput;
	        var firstMultiple = session.firstMultiple;
	        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
	
	        var center = input.center = getCenter(pointers);
	        input.timeStamp = now();
	        input.deltaTime = input.timeStamp - firstInput.timeStamp;
	
	        input.angle = getAngle(offsetCenter, center);
	        input.distance = getDistance(offsetCenter, center);
	
	        computeDeltaXY(session, input);
	        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
	
	        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	        input.overallVelocityX = overallVelocity.x;
	        input.overallVelocityY = overallVelocity.y;
	        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
	
	        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
	
	        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
	
	        computeIntervalInputData(session, input);
	
	        // find the correct target
	        var target = manager.element;
	        if (hasParent(input.srcEvent.target, target)) {
	            target = input.srcEvent.target;
	        }
	        input.target = target;
	    }
	
	    function computeDeltaXY(session, input) {
	        var center = input.center;
	        var offset = session.offsetDelta || {};
	        var prevDelta = session.prevDelta || {};
	        var prevInput = session.prevInput || {};
	
	        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	            prevDelta = session.prevDelta = {
	                x: prevInput.deltaX || 0,
	                y: prevInput.deltaY || 0
	            };
	
	            offset = session.offsetDelta = {
	                x: center.x,
	                y: center.y
	            };
	        }
	
	        input.deltaX = prevDelta.x + (center.x - offset.x);
	        input.deltaY = prevDelta.y + (center.y - offset.y);
	    }
	
	    /**
	     * velocity is calculated every x ms
	     * @param {Object} session
	     * @param {Object} input
	     */
	    function computeIntervalInputData(session, input) {
	        var last = session.lastInterval || input,
	            deltaTime = input.timeStamp - last.timeStamp,
	            velocity,
	            velocityX,
	            velocityY,
	            direction;
	
	        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	            var deltaX = input.deltaX - last.deltaX;
	            var deltaY = input.deltaY - last.deltaY;
	
	            var v = getVelocity(deltaTime, deltaX, deltaY);
	            velocityX = v.x;
	            velocityY = v.y;
	            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
	            direction = getDirection(deltaX, deltaY);
	
	            session.lastInterval = input;
	        } else {
	            // use latest velocity info if it doesn't overtake a minimum period
	            velocity = last.velocity;
	            velocityX = last.velocityX;
	            velocityY = last.velocityY;
	            direction = last.direction;
	        }
	
	        input.velocity = velocity;
	        input.velocityX = velocityX;
	        input.velocityY = velocityY;
	        input.direction = direction;
	    }
	
	    /**
	     * create a simple clone from the input used for storage of firstInput and firstMultiple
	     * @param {Object} input
	     * @returns {Object} clonedInputData
	     */
	    function simpleCloneInputData(input) {
	        // make a simple copy of the pointers because we will get a reference if we don't
	        // we only need clientXY for the calculations
	        var pointers = [];
	        var i = 0;
	        while (i < input.pointers.length) {
	            pointers[i] = {
	                clientX: round(input.pointers[i].clientX),
	                clientY: round(input.pointers[i].clientY)
	            };
	            i++;
	        }
	
	        return {
	            timeStamp: now(),
	            pointers: pointers,
	            center: getCenter(pointers),
	            deltaX: input.deltaX,
	            deltaY: input.deltaY
	        };
	    }
	
	    /**
	     * get the center of all the pointers
	     * @param {Array} pointers
	     * @return {Object} center contains `x` and `y` properties
	     */
	    function getCenter(pointers) {
	        var pointersLength = pointers.length;
	
	        // no need to loop when only one touch
	        if (pointersLength === 1) {
	            return {
	                x: round(pointers[0].clientX),
	                y: round(pointers[0].clientY)
	            };
	        }
	
	        var x = 0,
	            y = 0,
	            i = 0;
	        while (i < pointersLength) {
	            x += pointers[i].clientX;
	            y += pointers[i].clientY;
	            i++;
	        }
	
	        return {
	            x: round(x / pointersLength),
	            y: round(y / pointersLength)
	        };
	    }
	
	    /**
	     * calculate the velocity between two points. unit is in px per ms.
	     * @param {Number} deltaTime
	     * @param {Number} x
	     * @param {Number} y
	     * @return {Object} velocity `x` and `y`
	     */
	    function getVelocity(deltaTime, x, y) {
	        return {
	            x: x / deltaTime || 0,
	            y: y / deltaTime || 0
	        };
	    }
	
	    /**
	     * get the direction between two points
	     * @param {Number} x
	     * @param {Number} y
	     * @return {Number} direction
	     */
	    function getDirection(x, y) {
	        if (x === y) {
	            return DIRECTION_NONE;
	        }
	
	        if (abs(x) >= abs(y)) {
	            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	        }
	        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	    }
	
	    /**
	     * calculate the absolute distance between two points
	     * @param {Object} p1 {x, y}
	     * @param {Object} p2 {x, y}
	     * @param {Array} [props] containing x and y keys
	     * @return {Number} distance
	     */
	    function getDistance(p1, p2, props) {
	        if (!props) {
	            props = PROPS_XY;
	        }
	        var x = p2[props[0]] - p1[props[0]],
	            y = p2[props[1]] - p1[props[1]];
	
	        return Math.sqrt(x * x + y * y);
	    }
	
	    /**
	     * calculate the angle between two coordinates
	     * @param {Object} p1
	     * @param {Object} p2
	     * @param {Array} [props] containing x and y keys
	     * @return {Number} angle
	     */
	    function getAngle(p1, p2, props) {
	        if (!props) {
	            props = PROPS_XY;
	        }
	        var x = p2[props[0]] - p1[props[0]],
	            y = p2[props[1]] - p1[props[1]];
	        return Math.atan2(y, x) * 180 / Math.PI;
	    }
	
	    /**
	     * calculate the rotation degrees between two pointersets
	     * @param {Array} start array of pointers
	     * @param {Array} end array of pointers
	     * @return {Number} rotation
	     */
	    function getRotation(start, end) {
	        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
	    }
	
	    /**
	     * calculate the scale factor between two pointersets
	     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	     * @param {Array} start array of pointers
	     * @param {Array} end array of pointers
	     * @return {Number} scale
	     */
	    function getScale(start, end) {
	        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	    }
	
	    var MOUSE_INPUT_MAP = {
	        mousedown: INPUT_START,
	        mousemove: INPUT_MOVE,
	        mouseup: INPUT_END
	    };
	
	    var MOUSE_ELEMENT_EVENTS = 'mousedown';
	    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
	
	    /**
	     * Mouse events input
	     * @constructor
	     * @extends Input
	     */
	    function MouseInput() {
	        this.evEl = MOUSE_ELEMENT_EVENTS;
	        this.evWin = MOUSE_WINDOW_EVENTS;
	
	        this.pressed = false; // mousedown state
	
	        Input.apply(this, arguments);
	    }
	
	    inherit(MouseInput, Input, {
	        /**
	         * handle mouse events
	         * @param {Object} ev
	         */
	        handler: function MEhandler(ev) {
	            var eventType = MOUSE_INPUT_MAP[ev.type];
	
	            // on start we want to have the left mouse button down
	            if (eventType & INPUT_START && ev.button === 0) {
	                this.pressed = true;
	            }
	
	            if (eventType & INPUT_MOVE && ev.which !== 1) {
	                eventType = INPUT_END;
	            }
	
	            // mouse must be down
	            if (!this.pressed) {
	                return;
	            }
	
	            if (eventType & INPUT_END) {
	                this.pressed = false;
	            }
	
	            this.callback(this.manager, eventType, {
	                pointers: [ev],
	                changedPointers: [ev],
	                pointerType: INPUT_TYPE_MOUSE,
	                srcEvent: ev
	            });
	        }
	    });
	
	    var POINTER_INPUT_MAP = {
	        pointerdown: INPUT_START,
	        pointermove: INPUT_MOVE,
	        pointerup: INPUT_END,
	        pointercancel: INPUT_CANCEL,
	        pointerout: INPUT_CANCEL
	    };
	
	    // in IE10 the pointer types is defined as an enum
	    var IE10_POINTER_TYPE_ENUM = {
	        2: INPUT_TYPE_TOUCH,
	        3: INPUT_TYPE_PEN,
	        4: INPUT_TYPE_MOUSE,
	        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	    };
	
	    var POINTER_ELEMENT_EVENTS = 'pointerdown';
	    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
	
	    // IE10 has prefixed support, and case-sensitive
	    if (window.MSPointerEvent && !window.PointerEvent) {
	        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	    }
	
	    /**
	     * Pointer events input
	     * @constructor
	     * @extends Input
	     */
	    function PointerEventInput() {
	        this.evEl = POINTER_ELEMENT_EVENTS;
	        this.evWin = POINTER_WINDOW_EVENTS;
	
	        Input.apply(this, arguments);
	
	        this.store = this.manager.session.pointerEvents = [];
	    }
	
	    inherit(PointerEventInput, Input, {
	        /**
	         * handle mouse events
	         * @param {Object} ev
	         */
	        handler: function PEhandler(ev) {
	            var store = this.store;
	            var removePointer = false;
	
	            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
	
	            var isTouch = pointerType == INPUT_TYPE_TOUCH;
	
	            // get index of the event in the store
	            var storeIndex = inArray(store, ev.pointerId, 'pointerId');
	
	            // start and mouse must be down
	            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	                if (storeIndex < 0) {
	                    store.push(ev);
	                    storeIndex = store.length - 1;
	                }
	            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	                removePointer = true;
	            }
	
	            // it not found, so the pointer hasn't been down (so it's probably a hover)
	            if (storeIndex < 0) {
	                return;
	            }
	
	            // update the event in the store
	            store[storeIndex] = ev;
	
	            this.callback(this.manager, eventType, {
	                pointers: store,
	                changedPointers: [ev],
	                pointerType: pointerType,
	                srcEvent: ev
	            });
	
	            if (removePointer) {
	                // remove from the store
	                store.splice(storeIndex, 1);
	            }
	        }
	    });
	
	    var SINGLE_TOUCH_INPUT_MAP = {
	        touchstart: INPUT_START,
	        touchmove: INPUT_MOVE,
	        touchend: INPUT_END,
	        touchcancel: INPUT_CANCEL
	    };
	
	    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
	
	    /**
	     * Touch events input
	     * @constructor
	     * @extends Input
	     */
	    function SingleTouchInput() {
	        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	        this.started = false;
	
	        Input.apply(this, arguments);
	    }
	
	    inherit(SingleTouchInput, Input, {
	        handler: function TEhandler(ev) {
	            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
	
	            // should we handle the touch events?
	            if (type === INPUT_START) {
	                this.started = true;
	            }
	
	            if (!this.started) {
	                return;
	            }
	
	            var touches = normalizeSingleTouches.call(this, ev, type);
	
	            // when done, reset the started state
	            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	                this.started = false;
	            }
	
	            this.callback(this.manager, type, {
	                pointers: touches[0],
	                changedPointers: touches[1],
	                pointerType: INPUT_TYPE_TOUCH,
	                srcEvent: ev
	            });
	        }
	    });
	
	    /**
	     * @this {TouchInput}
	     * @param {Object} ev
	     * @param {Number} type flag
	     * @returns {undefined|Array} [all, changed]
	     */
	    function normalizeSingleTouches(ev, type) {
	        var all = toArray(ev.touches);
	        var changed = toArray(ev.changedTouches);
	
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            all = uniqueArray(all.concat(changed), 'identifier', true);
	        }
	
	        return [all, changed];
	    }
	
	    var TOUCH_INPUT_MAP = {
	        touchstart: INPUT_START,
	        touchmove: INPUT_MOVE,
	        touchend: INPUT_END,
	        touchcancel: INPUT_CANCEL
	    };
	
	    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
	
	    /**
	     * Multi-user touch events input
	     * @constructor
	     * @extends Input
	     */
	    function TouchInput() {
	        this.evTarget = TOUCH_TARGET_EVENTS;
	        this.targetIds = {};
	
	        Input.apply(this, arguments);
	    }
	
	    inherit(TouchInput, Input, {
	        handler: function MTEhandler(ev) {
	            var type = TOUCH_INPUT_MAP[ev.type];
	            var touches = getTouches.call(this, ev, type);
	            if (!touches) {
	                return;
	            }
	
	            this.callback(this.manager, type, {
	                pointers: touches[0],
	                changedPointers: touches[1],
	                pointerType: INPUT_TYPE_TOUCH,
	                srcEvent: ev
	            });
	        }
	    });
	
	    /**
	     * @this {TouchInput}
	     * @param {Object} ev
	     * @param {Number} type flag
	     * @returns {undefined|Array} [all, changed]
	     */
	    function getTouches(ev, type) {
	        var allTouches = toArray(ev.touches);
	        var targetIds = this.targetIds;
	
	        // when there is only one touch, the process can be simplified
	        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	            targetIds[allTouches[0].identifier] = true;
	            return [allTouches, allTouches];
	        }
	
	        var i,
	            targetTouches,
	            changedTouches = toArray(ev.changedTouches),
	            changedTargetTouches = [],
	            target = this.target;
	
	        // get target touches from touches
	        targetTouches = allTouches.filter(function (touch) {
	            return hasParent(touch.target, target);
	        });
	
	        // collect touches
	        if (type === INPUT_START) {
	            i = 0;
	            while (i < targetTouches.length) {
	                targetIds[targetTouches[i].identifier] = true;
	                i++;
	            }
	        }
	
	        // filter changed touches to only contain touches that exist in the collected target ids
	        i = 0;
	        while (i < changedTouches.length) {
	            if (targetIds[changedTouches[i].identifier]) {
	                changedTargetTouches.push(changedTouches[i]);
	            }
	
	            // cleanup removed touches
	            if (type & (INPUT_END | INPUT_CANCEL)) {
	                delete targetIds[changedTouches[i].identifier];
	            }
	            i++;
	        }
	
	        if (!changedTargetTouches.length) {
	            return;
	        }
	
	        return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
	    }
	
	    /**
	     * Combined touch and mouse input
	     *
	     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	     * This because touch devices also emit mouse events while doing a touch.
	     *
	     * @constructor
	     * @extends Input
	     */
	
	    var DEDUP_TIMEOUT = 2500;
	    var DEDUP_DISTANCE = 25;
	
	    function TouchMouseInput() {
	        Input.apply(this, arguments);
	
	        var handler = bindFn(this.handler, this);
	        this.touch = new TouchInput(this.manager, handler);
	        this.mouse = new MouseInput(this.manager, handler);
	
	        this.primaryTouch = null;
	        this.lastTouches = [];
	    }
	
	    inherit(TouchMouseInput, Input, {
	        /**
	         * handle mouse and touch events
	         * @param {Hammer} manager
	         * @param {String} inputEvent
	         * @param {Object} inputData
	         */
	        handler: function TMEhandler(manager, inputEvent, inputData) {
	            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
	                isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
	
	            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
	                return;
	            }
	
	            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
	            if (isTouch) {
	                recordTouches.call(this, inputEvent, inputData);
	            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
	                return;
	            }
	
	            this.callback(manager, inputEvent, inputData);
	        },
	
	        /**
	         * remove the event listeners
	         */
	        destroy: function destroy() {
	            this.touch.destroy();
	            this.mouse.destroy();
	        }
	    });
	
	    function recordTouches(eventType, eventData) {
	        if (eventType & INPUT_START) {
	            this.primaryTouch = eventData.changedPointers[0].identifier;
	            setLastTouch.call(this, eventData);
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            setLastTouch.call(this, eventData);
	        }
	    }
	
	    function setLastTouch(eventData) {
	        var touch = eventData.changedPointers[0];
	
	        if (touch.identifier === this.primaryTouch) {
	            var lastTouch = { x: touch.clientX, y: touch.clientY };
	            this.lastTouches.push(lastTouch);
	            var lts = this.lastTouches;
	            var removeLastTouch = function removeLastTouch() {
	                var i = lts.indexOf(lastTouch);
	                if (i > -1) {
	                    lts.splice(i, 1);
	                }
	            };
	            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
	        }
	    }
	
	    function isSyntheticEvent(eventData) {
	        var x = eventData.srcEvent.clientX,
	            y = eventData.srcEvent.clientY;
	        for (var i = 0; i < this.lastTouches.length; i++) {
	            var t = this.lastTouches[i];
	            var dx = Math.abs(x - t.x),
	                dy = Math.abs(y - t.y);
	            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
	
	    // magical touchAction value
	    var TOUCH_ACTION_COMPUTE = 'compute';
	    var TOUCH_ACTION_AUTO = 'auto';
	    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	    var TOUCH_ACTION_NONE = 'none';
	    var TOUCH_ACTION_PAN_X = 'pan-x';
	    var TOUCH_ACTION_PAN_Y = 'pan-y';
	    var TOUCH_ACTION_MAP = getTouchActionProps();
	
	    /**
	     * Touch Action
	     * sets the touchAction property or uses the js alternative
	     * @param {Manager} manager
	     * @param {String} value
	     * @constructor
	     */
	    function TouchAction(manager, value) {
	        this.manager = manager;
	        this.set(value);
	    }
	
	    TouchAction.prototype = {
	        /**
	         * set the touchAction value on the element or enable the polyfill
	         * @param {String} value
	         */
	        set: function set(value) {
	            // find out the touch-action by the event handlers
	            if (value == TOUCH_ACTION_COMPUTE) {
	                value = this.compute();
	            }
	
	            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
	                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	            }
	            this.actions = value.toLowerCase().trim();
	        },
	
	        /**
	         * just re-set the touchAction value
	         */
	        update: function update() {
	            this.set(this.manager.options.touchAction);
	        },
	
	        /**
	         * compute the value for the touchAction property based on the recognizer's settings
	         * @returns {String} value
	         */
	        compute: function compute() {
	            var actions = [];
	            each(this.manager.recognizers, function (recognizer) {
	                if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                    actions = actions.concat(recognizer.getTouchAction());
	                }
	            });
	            return cleanTouchActions(actions.join(' '));
	        },
	
	        /**
	         * this method is called on each input cycle and provides the preventing of the browser behavior
	         * @param {Object} input
	         */
	        preventDefaults: function preventDefaults(input) {
	            var srcEvent = input.srcEvent;
	            var direction = input.offsetDirection;
	
	            // if the touch action did prevented once this session
	            if (this.manager.session.prevented) {
	                srcEvent.preventDefault();
	                return;
	            }
	
	            var actions = this.actions;
	            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
	            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
	            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
	
	            if (hasNone) {
	                //do not prevent defaults if this is a tap gesture
	
	                var isTapPointer = input.pointers.length === 1;
	                var isTapMovement = input.distance < 2;
	                var isTapTouchTime = input.deltaTime < 250;
	
	                if (isTapPointer && isTapMovement && isTapTouchTime) {
	                    return;
	                }
	            }
	
	            if (hasPanX && hasPanY) {
	                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
	                return;
	            }
	
	            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
	                return this.preventSrc(srcEvent);
	            }
	        },
	
	        /**
	         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	         * @param {Object} srcEvent
	         */
	        preventSrc: function preventSrc(srcEvent) {
	            this.manager.session.prevented = true;
	            srcEvent.preventDefault();
	        }
	    };
	
	    /**
	     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	     * @param {String} actions
	     * @returns {*}
	     */
	    function cleanTouchActions(actions) {
	        // none
	        if (inStr(actions, TOUCH_ACTION_NONE)) {
	            return TOUCH_ACTION_NONE;
	        }
	
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
	
	        // if both pan-x and pan-y are set (different recognizers
	        // for different directions, e.g. horizontal pan but vertical swipe?)
	        // we need none (as otherwise with pan-x pan-y combined none of these
	        // recognizers will work, since the browser would handle all panning
	        if (hasPanX && hasPanY) {
	            return TOUCH_ACTION_NONE;
	        }
	
	        // pan-x OR pan-y
	        if (hasPanX || hasPanY) {
	            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	        }
	
	        // manipulation
	        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	            return TOUCH_ACTION_MANIPULATION;
	        }
	
	        return TOUCH_ACTION_AUTO;
	    }
	
	    function getTouchActionProps() {
	        if (!NATIVE_TOUCH_ACTION) {
	            return false;
	        }
	        var touchMap = {};
	        var cssSupports = window.CSS && window.CSS.supports;
	        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
	
	            // If css.supports is not supported but there is native touch-action assume it supports
	            // all values. This is the case for IE 10 and 11.
	            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
	        });
	        return touchMap;
	    }
	
	    /**
	     * Recognizer flow explained; *
	     * All recognizers have the initial state of POSSIBLE when a input session starts.
	     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	     * Example session for mouse-input: mousedown -> mousemove -> mouseup
	     *
	     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	     * which determines with state it should be.
	     *
	     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	     * POSSIBLE to give it another change on the next cycle.
	     *
	     *               Possible
	     *                  |
	     *            +-----+---------------+
	     *            |                     |
	     *      +-----+-----+               |
	     *      |           |               |
	     *   Failed      Cancelled          |
	     *                          +-------+------+
	     *                          |              |
	     *                      Recognized       Began
	     *                                         |
	     *                                      Changed
	     *                                         |
	     *                                  Ended/Recognized
	     */
	    var STATE_POSSIBLE = 1;
	    var STATE_BEGAN = 2;
	    var STATE_CHANGED = 4;
	    var STATE_ENDED = 8;
	    var STATE_RECOGNIZED = STATE_ENDED;
	    var STATE_CANCELLED = 16;
	    var STATE_FAILED = 32;
	
	    /**
	     * Recognizer
	     * Every recognizer needs to extend from this class.
	     * @constructor
	     * @param {Object} options
	     */
	    function Recognizer(options) {
	        this.options = assign({}, this.defaults, options || {});
	
	        this.id = uniqueId();
	
	        this.manager = null;
	
	        // default is enable true
	        this.options.enable = ifUndefined(this.options.enable, true);
	
	        this.state = STATE_POSSIBLE;
	
	        this.simultaneous = {};
	        this.requireFail = [];
	    }
	
	    Recognizer.prototype = {
	        /**
	         * @virtual
	         * @type {Object}
	         */
	        defaults: {},
	
	        /**
	         * set options
	         * @param {Object} options
	         * @return {Recognizer}
	         */
	        set: function set(options) {
	            assign(this.options, options);
	
	            // also update the touchAction, in case something changed about the directions/enabled state
	            this.manager && this.manager.touchAction.update();
	            return this;
	        },
	
	        /**
	         * recognize simultaneous with an other recognizer.
	         * @param {Recognizer} otherRecognizer
	         * @returns {Recognizer} this
	         */
	        recognizeWith: function recognizeWith(otherRecognizer) {
	            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	                return this;
	            }
	
	            var simultaneous = this.simultaneous;
	            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	            if (!simultaneous[otherRecognizer.id]) {
	                simultaneous[otherRecognizer.id] = otherRecognizer;
	                otherRecognizer.recognizeWith(this);
	            }
	            return this;
	        },
	
	        /**
	         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	         * @param {Recognizer} otherRecognizer
	         * @returns {Recognizer} this
	         */
	        dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
	            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	                return this;
	            }
	
	            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	            delete this.simultaneous[otherRecognizer.id];
	            return this;
	        },
	
	        /**
	         * recognizer can only run when an other is failing
	         * @param {Recognizer} otherRecognizer
	         * @returns {Recognizer} this
	         */
	        requireFailure: function requireFailure(otherRecognizer) {
	            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	                return this;
	            }
	
	            var requireFail = this.requireFail;
	            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	            if (inArray(requireFail, otherRecognizer) === -1) {
	                requireFail.push(otherRecognizer);
	                otherRecognizer.requireFailure(this);
	            }
	            return this;
	        },
	
	        /**
	         * drop the requireFailure link. it does not remove the link on the other recognizer.
	         * @param {Recognizer} otherRecognizer
	         * @returns {Recognizer} this
	         */
	        dropRequireFailure: function dropRequireFailure(otherRecognizer) {
	            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	                return this;
	            }
	
	            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	            var index = inArray(this.requireFail, otherRecognizer);
	            if (index > -1) {
	                this.requireFail.splice(index, 1);
	            }
	            return this;
	        },
	
	        /**
	         * has require failures boolean
	         * @returns {boolean}
	         */
	        hasRequireFailures: function hasRequireFailures() {
	            return this.requireFail.length > 0;
	        },
	
	        /**
	         * if the recognizer can recognize simultaneous with an other recognizer
	         * @param {Recognizer} otherRecognizer
	         * @returns {Boolean}
	         */
	        canRecognizeWith: function canRecognizeWith(otherRecognizer) {
	            return !!this.simultaneous[otherRecognizer.id];
	        },
	
	        /**
	         * You should use `tryEmit` instead of `emit` directly to check
	         * that all the needed recognizers has failed before emitting.
	         * @param {Object} input
	         */
	        emit: function emit(input) {
	            var self = this;
	            var state = this.state;
	
	            function emit(event) {
	                self.manager.emit(event, input);
	            }
	
	            // 'panstart' and 'panmove'
	            if (state < STATE_ENDED) {
	                emit(self.options.event + stateStr(state));
	            }
	
	            emit(self.options.event); // simple 'eventName' events
	
	            if (input.additionalEvent) {
	                // additional event(panleft, panright, pinchin, pinchout...)
	                emit(input.additionalEvent);
	            }
	
	            // panend and pancancel
	            if (state >= STATE_ENDED) {
	                emit(self.options.event + stateStr(state));
	            }
	        },
	
	        /**
	         * Check that all the require failure recognizers has failed,
	         * if true, it emits a gesture event,
	         * otherwise, setup the state to FAILED.
	         * @param {Object} input
	         */
	        tryEmit: function tryEmit(input) {
	            if (this.canEmit()) {
	                return this.emit(input);
	            }
	            // it's failing anyway
	            this.state = STATE_FAILED;
	        },
	
	        /**
	         * can we emit?
	         * @returns {boolean}
	         */
	        canEmit: function canEmit() {
	            var i = 0;
	            while (i < this.requireFail.length) {
	                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                    return false;
	                }
	                i++;
	            }
	            return true;
	        },
	
	        /**
	         * update the recognizer
	         * @param {Object} inputData
	         */
	        recognize: function recognize(inputData) {
	            // make a new copy of the inputData
	            // so we can change the inputData without messing up the other recognizers
	            var inputDataClone = assign({}, inputData);
	
	            // is is enabled and allow recognizing?
	            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	                this.reset();
	                this.state = STATE_FAILED;
	                return;
	            }
	
	            // reset when we've reached the end
	            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	                this.state = STATE_POSSIBLE;
	            }
	
	            this.state = this.process(inputDataClone);
	
	            // the recognizer has recognized a gesture
	            // so trigger an event
	            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	                this.tryEmit(inputDataClone);
	            }
	        },
	
	        /**
	         * return the state of the recognizer
	         * the actual recognizing happens in this method
	         * @virtual
	         * @param {Object} inputData
	         * @returns {Const} STATE
	         */
	        process: function process(inputData) {}, // jshint ignore:line
	
	        /**
	         * return the preferred touch-action
	         * @virtual
	         * @returns {Array}
	         */
	        getTouchAction: function getTouchAction() {},
	
	        /**
	         * called when the gesture isn't allowed to recognize
	         * like when another is being recognized or it is disabled
	         * @virtual
	         */
	        reset: function reset() {}
	    };
	
	    /**
	     * get a usable string, used as event postfix
	     * @param {Const} state
	     * @returns {String} state
	     */
	    function stateStr(state) {
	        if (state & STATE_CANCELLED) {
	            return 'cancel';
	        } else if (state & STATE_ENDED) {
	            return 'end';
	        } else if (state & STATE_CHANGED) {
	            return 'move';
	        } else if (state & STATE_BEGAN) {
	            return 'start';
	        }
	        return '';
	    }
	
	    /**
	     * direction cons to string
	     * @param {Const} direction
	     * @returns {String}
	     */
	    function directionStr(direction) {
	        if (direction == DIRECTION_DOWN) {
	            return 'down';
	        } else if (direction == DIRECTION_UP) {
	            return 'up';
	        } else if (direction == DIRECTION_LEFT) {
	            return 'left';
	        } else if (direction == DIRECTION_RIGHT) {
	            return 'right';
	        }
	        return '';
	    }
	
	    /**
	     * get a recognizer by name if it is bound to a manager
	     * @param {Recognizer|String} otherRecognizer
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer}
	     */
	    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	        var manager = recognizer.manager;
	        if (manager) {
	            return manager.get(otherRecognizer);
	        }
	        return otherRecognizer;
	    }
	
	    /**
	     * This recognizer is just used as a base for the simple attribute recognizers.
	     * @constructor
	     * @extends Recognizer
	     */
	    function AttrRecognizer() {
	        Recognizer.apply(this, arguments);
	    }
	
	    inherit(AttrRecognizer, Recognizer, {
	        /**
	         * @namespace
	         * @memberof AttrRecognizer
	         */
	        defaults: {
	            /**
	             * @type {Number}
	             * @default 1
	             */
	            pointers: 1
	        },
	
	        /**
	         * Used to check if it the recognizer receives valid input, like input.distance > 10.
	         * @memberof AttrRecognizer
	         * @param {Object} input
	         * @returns {Boolean} recognized
	         */
	        attrTest: function attrTest(input) {
	            var optionPointers = this.options.pointers;
	            return optionPointers === 0 || input.pointers.length === optionPointers;
	        },
	
	        /**
	         * Process the input and return the state for the recognizer
	         * @memberof AttrRecognizer
	         * @param {Object} input
	         * @returns {*} State
	         */
	        process: function process(input) {
	            var state = this.state;
	            var eventType = input.eventType;
	
	            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	            var isValid = this.attrTest(input);
	
	            // on cancel input and we've recognized before, return STATE_CANCELLED
	            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	                return state | STATE_CANCELLED;
	            } else if (isRecognized || isValid) {
	                if (eventType & INPUT_END) {
	                    return state | STATE_ENDED;
	                } else if (!(state & STATE_BEGAN)) {
	                    return STATE_BEGAN;
	                }
	                return state | STATE_CHANGED;
	            }
	            return STATE_FAILED;
	        }
	    });
	
	    /**
	     * Pan
	     * Recognized when the pointer is down and moved in the allowed direction.
	     * @constructor
	     * @extends AttrRecognizer
	     */
	    function PanRecognizer() {
	        AttrRecognizer.apply(this, arguments);
	
	        this.pX = null;
	        this.pY = null;
	    }
	
	    inherit(PanRecognizer, AttrRecognizer, {
	        /**
	         * @namespace
	         * @memberof PanRecognizer
	         */
	        defaults: {
	            event: 'pan',
	            threshold: 10,
	            pointers: 1,
	            direction: DIRECTION_ALL
	        },
	
	        getTouchAction: function getTouchAction() {
	            var direction = this.options.direction;
	            var actions = [];
	            if (direction & DIRECTION_HORIZONTAL) {
	                actions.push(TOUCH_ACTION_PAN_Y);
	            }
	            if (direction & DIRECTION_VERTICAL) {
	                actions.push(TOUCH_ACTION_PAN_X);
	            }
	            return actions;
	        },
	
	        directionTest: function directionTest(input) {
	            var options = this.options;
	            var hasMoved = true;
	            var distance = input.distance;
	            var direction = input.direction;
	            var x = input.deltaX;
	            var y = input.deltaY;
	
	            // lock to axis?
	            if (!(direction & options.direction)) {
	                if (options.direction & DIRECTION_HORIZONTAL) {
	                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                    hasMoved = x != this.pX;
	                    distance = Math.abs(input.deltaX);
	                } else {
	                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	                    hasMoved = y != this.pY;
	                    distance = Math.abs(input.deltaY);
	                }
	            }
	            input.direction = direction;
	            return hasMoved && distance > options.threshold && direction & options.direction;
	        },
	
	        attrTest: function attrTest(input) {
	            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
	        },
	
	        emit: function emit(input) {
	
	            this.pX = input.deltaX;
	            this.pY = input.deltaY;
	
	            var direction = directionStr(input.direction);
	
	            if (direction) {
	                input.additionalEvent = this.options.event + direction;
	            }
	            this._super.emit.call(this, input);
	        }
	    });
	
	    /**
	     * Pinch
	     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	     * @constructor
	     * @extends AttrRecognizer
	     */
	    function PinchRecognizer() {
	        AttrRecognizer.apply(this, arguments);
	    }
	
	    inherit(PinchRecognizer, AttrRecognizer, {
	        /**
	         * @namespace
	         * @memberof PinchRecognizer
	         */
	        defaults: {
	            event: 'pinch',
	            threshold: 0,
	            pointers: 2
	        },
	
	        getTouchAction: function getTouchAction() {
	            return [TOUCH_ACTION_NONE];
	        },
	
	        attrTest: function attrTest(input) {
	            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	        },
	
	        emit: function emit(input) {
	            if (input.scale !== 1) {
	                var inOut = input.scale < 1 ? 'in' : 'out';
	                input.additionalEvent = this.options.event + inOut;
	            }
	            this._super.emit.call(this, input);
	        }
	    });
	
	    /**
	     * Press
	     * Recognized when the pointer is down for x ms without any movement.
	     * @constructor
	     * @extends Recognizer
	     */
	    function PressRecognizer() {
	        Recognizer.apply(this, arguments);
	
	        this._timer = null;
	        this._input = null;
	    }
	
	    inherit(PressRecognizer, Recognizer, {
	        /**
	         * @namespace
	         * @memberof PressRecognizer
	         */
	        defaults: {
	            event: 'press',
	            pointers: 1,
	            time: 251, // minimal time of the pointer to be pressed
	            threshold: 9 // a minimal movement is ok, but keep it low
	        },
	
	        getTouchAction: function getTouchAction() {
	            return [TOUCH_ACTION_AUTO];
	        },
	
	        process: function process(input) {
	            var options = this.options;
	            var validPointers = input.pointers.length === options.pointers;
	            var validMovement = input.distance < options.threshold;
	            var validTime = input.deltaTime > options.time;
	
	            this._input = input;
	
	            // we only allow little movement
	            // and we've reached an end event, so a tap is possible
	            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
	                this.reset();
	            } else if (input.eventType & INPUT_START) {
	                this.reset();
	                this._timer = setTimeoutContext(function () {
	                    this.state = STATE_RECOGNIZED;
	                    this.tryEmit();
	                }, options.time, this);
	            } else if (input.eventType & INPUT_END) {
	                return STATE_RECOGNIZED;
	            }
	            return STATE_FAILED;
	        },
	
	        reset: function reset() {
	            clearTimeout(this._timer);
	        },
	
	        emit: function emit(input) {
	            if (this.state !== STATE_RECOGNIZED) {
	                return;
	            }
	
	            if (input && input.eventType & INPUT_END) {
	                this.manager.emit(this.options.event + 'up', input);
	            } else {
	                this._input.timeStamp = now();
	                this.manager.emit(this.options.event, this._input);
	            }
	        }
	    });
	
	    /**
	     * Rotate
	     * Recognized when two or more pointer are moving in a circular motion.
	     * @constructor
	     * @extends AttrRecognizer
	     */
	    function RotateRecognizer() {
	        AttrRecognizer.apply(this, arguments);
	    }
	
	    inherit(RotateRecognizer, AttrRecognizer, {
	        /**
	         * @namespace
	         * @memberof RotateRecognizer
	         */
	        defaults: {
	            event: 'rotate',
	            threshold: 0,
	            pointers: 2
	        },
	
	        getTouchAction: function getTouchAction() {
	            return [TOUCH_ACTION_NONE];
	        },
	
	        attrTest: function attrTest(input) {
	            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	        }
	    });
	
	    /**
	     * Swipe
	     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	     * @constructor
	     * @extends AttrRecognizer
	     */
	    function SwipeRecognizer() {
	        AttrRecognizer.apply(this, arguments);
	    }
	
	    inherit(SwipeRecognizer, AttrRecognizer, {
	        /**
	         * @namespace
	         * @memberof SwipeRecognizer
	         */
	        defaults: {
	            event: 'swipe',
	            threshold: 10,
	            velocity: 0.3,
	            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	            pointers: 1
	        },
	
	        getTouchAction: function getTouchAction() {
	            return PanRecognizer.prototype.getTouchAction.call(this);
	        },
	
	        attrTest: function attrTest(input) {
	            var direction = this.options.direction;
	            var velocity;
	
	            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	                velocity = input.overallVelocity;
	            } else if (direction & DIRECTION_HORIZONTAL) {
	                velocity = input.overallVelocityX;
	            } else if (direction & DIRECTION_VERTICAL) {
	                velocity = input.overallVelocityY;
	            }
	
	            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	        },
	
	        emit: function emit(input) {
	            var direction = directionStr(input.offsetDirection);
	            if (direction) {
	                this.manager.emit(this.options.event + direction, input);
	            }
	
	            this.manager.emit(this.options.event, input);
	        }
	    });
	
	    /**
	     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	     * a single tap.
	     *
	     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	     * multi-taps being recognized.
	     * @constructor
	     * @extends Recognizer
	     */
	    function TapRecognizer() {
	        Recognizer.apply(this, arguments);
	
	        // previous time and center,
	        // used for tap counting
	        this.pTime = false;
	        this.pCenter = false;
	
	        this._timer = null;
	        this._input = null;
	        this.count = 0;
	    }
	
	    inherit(TapRecognizer, Recognizer, {
	        /**
	         * @namespace
	         * @memberof PinchRecognizer
	         */
	        defaults: {
	            event: 'tap',
	            pointers: 1,
	            taps: 1,
	            interval: 300, // max time between the multi-tap taps
	            time: 250, // max time of the pointer to be down (like finger on the screen)
	            threshold: 9, // a minimal movement is ok, but keep it low
	            posThreshold: 10 // a multi-tap can be a bit off the initial position
	        },
	
	        getTouchAction: function getTouchAction() {
	            return [TOUCH_ACTION_MANIPULATION];
	        },
	
	        process: function process(input) {
	            var options = this.options;
	
	            var validPointers = input.pointers.length === options.pointers;
	            var validMovement = input.distance < options.threshold;
	            var validTouchTime = input.deltaTime < options.time;
	
	            this.reset();
	
	            if (input.eventType & INPUT_START && this.count === 0) {
	                return this.failTimeout();
	            }
	
	            // we only allow little movement
	            // and we've reached an end event, so a tap is possible
	            if (validMovement && validTouchTime && validPointers) {
	                if (input.eventType != INPUT_END) {
	                    return this.failTimeout();
	                }
	
	                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
	                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
	
	                this.pTime = input.timeStamp;
	                this.pCenter = input.center;
	
	                if (!validMultiTap || !validInterval) {
	                    this.count = 1;
	                } else {
	                    this.count += 1;
	                }
	
	                this._input = input;
	
	                // if tap count matches we have recognized it,
	                // else it has began recognizing...
	                var tapCount = this.count % options.taps;
	                if (tapCount === 0) {
	                    // no failing requirements, immediately trigger the tap event
	                    // or wait as long as the multitap interval to trigger
	                    if (!this.hasRequireFailures()) {
	                        return STATE_RECOGNIZED;
	                    } else {
	                        this._timer = setTimeoutContext(function () {
	                            this.state = STATE_RECOGNIZED;
	                            this.tryEmit();
	                        }, options.interval, this);
	                        return STATE_BEGAN;
	                    }
	                }
	            }
	            return STATE_FAILED;
	        },
	
	        failTimeout: function failTimeout() {
	            this._timer = setTimeoutContext(function () {
	                this.state = STATE_FAILED;
	            }, this.options.interval, this);
	            return STATE_FAILED;
	        },
	
	        reset: function reset() {
	            clearTimeout(this._timer);
	        },
	
	        emit: function emit() {
	            if (this.state == STATE_RECOGNIZED) {
	                this._input.tapCount = this.count;
	                this.manager.emit(this.options.event, this._input);
	            }
	        }
	    });
	
	    /**
	     * Simple way to create a manager with a default set of recognizers.
	     * @param {HTMLElement} element
	     * @param {Object} [options]
	     * @constructor
	     */
	    function Hammer(element, options) {
	        options = options || {};
	        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	        return new Manager(element, options);
	    }
	
	    /**
	     * @const {string}
	     */
	    Hammer.VERSION = '2.0.7';
	
	    /**
	     * default settings
	     * @namespace
	     */
	    Hammer.defaults = {
	        /**
	         * set if DOM events are being triggered.
	         * But this is slower and unused by simple implementations, so disabled by default.
	         * @type {Boolean}
	         * @default false
	         */
	        domEvents: false,
	
	        /**
	         * The value for the touchAction property/fallback.
	         * When set to `compute` it will magically set the correct value based on the added recognizers.
	         * @type {String}
	         * @default compute
	         */
	        touchAction: TOUCH_ACTION_COMPUTE,
	
	        /**
	         * @type {Boolean}
	         * @default true
	         */
	        enable: true,
	
	        /**
	         * EXPERIMENTAL FEATURE -- can be removed/changed
	         * Change the parent input target element.
	         * If Null, then it is being set the to main element.
	         * @type {Null|EventTarget}
	         * @default null
	         */
	        inputTarget: null,
	
	        /**
	         * force an input class
	         * @type {Null|Function}
	         * @default null
	         */
	        inputClass: null,
	
	        /**
	         * Default recognizer setup when calling `Hammer()`
	         * When creating a new Manager these will be skipped.
	         * @type {Array}
	         */
	        preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],
	
	        /**
	         * Some CSS properties can be used to improve the working of Hammer.
	         * Add them to this method and they will be set when creating a new Manager.
	         * @namespace
	         */
	        cssProps: {
	            /**
	             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	             * @type {String}
	             * @default 'none'
	             */
	            userSelect: 'none',
	
	            /**
	             * Disable the Windows Phone grippers when pressing an element.
	             * @type {String}
	             * @default 'none'
	             */
	            touchSelect: 'none',
	
	            /**
	             * Disables the default callout shown when you touch and hold a touch target.
	             * On iOS, when you touch and hold a touch target such as a link, Safari displays
	             * a callout containing information about the link. This property allows you to disable that callout.
	             * @type {String}
	             * @default 'none'
	             */
	            touchCallout: 'none',
	
	            /**
	             * Specifies whether zooming is enabled. Used by IE10>
	             * @type {String}
	             * @default 'none'
	             */
	            contentZooming: 'none',
	
	            /**
	             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	             * @type {String}
	             * @default 'none'
	             */
	            userDrag: 'none',
	
	            /**
	             * Overrides the highlight color shown when the user taps a link or a JavaScript
	             * clickable element in iOS. This property obeys the alpha value, if specified.
	             * @type {String}
	             * @default 'rgba(0,0,0,0)'
	             */
	            tapHighlightColor: 'rgba(0,0,0,0)'
	        }
	    };
	
	    var STOP = 1;
	    var FORCED_STOP = 2;
	
	    /**
	     * Manager
	     * @param {HTMLElement} element
	     * @param {Object} [options]
	     * @constructor
	     */
	    function Manager(element, options) {
	        this.options = assign({}, Hammer.defaults, options || {});
	
	        this.options.inputTarget = this.options.inputTarget || element;
	
	        this.handlers = {};
	        this.session = {};
	        this.recognizers = [];
	        this.oldCssProps = {};
	
	        this.element = element;
	        this.input = createInputInstance(this);
	        this.touchAction = new TouchAction(this, this.options.touchAction);
	
	        toggleCssProps(this, true);
	
	        each(this.options.recognizers, function (item) {
	            var recognizer = this.add(new item[0](item[1]));
	            item[2] && recognizer.recognizeWith(item[2]);
	            item[3] && recognizer.requireFailure(item[3]);
	        }, this);
	    }
	
	    Manager.prototype = {
	        /**
	         * set options
	         * @param {Object} options
	         * @returns {Manager}
	         */
	        set: function set(options) {
	            assign(this.options, options);
	
	            // Options that need a little more setup
	            if (options.touchAction) {
	                this.touchAction.update();
	            }
	            if (options.inputTarget) {
	                // Clean up existing event listeners and reinitialize
	                this.input.destroy();
	                this.input.target = options.inputTarget;
	                this.input.init();
	            }
	            return this;
	        },
	
	        /**
	         * stop recognizing for this session.
	         * This session will be discarded, when a new [input]start event is fired.
	         * When forced, the recognizer cycle is stopped immediately.
	         * @param {Boolean} [force]
	         */
	        stop: function stop(force) {
	            this.session.stopped = force ? FORCED_STOP : STOP;
	        },
	
	        /**
	         * run the recognizers!
	         * called by the inputHandler function on every movement of the pointers (touches)
	         * it walks through all the recognizers and tries to detect the gesture that is being made
	         * @param {Object} inputData
	         */
	        recognize: function recognize(inputData) {
	            var session = this.session;
	            if (session.stopped) {
	                return;
	            }
	
	            // run the touch-action polyfill
	            this.touchAction.preventDefaults(inputData);
	
	            var recognizer;
	            var recognizers = this.recognizers;
	
	            // this holds the recognizer that is being recognized.
	            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	            // if no recognizer is detecting a thing, it is set to `null`
	            var curRecognizer = session.curRecognizer;
	
	            // reset when the last recognizer is recognized
	            // or when we're in a new session
	            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
	                curRecognizer = session.curRecognizer = null;
	            }
	
	            var i = 0;
	            while (i < recognizers.length) {
	                recognizer = recognizers[i];
	
	                // find out if we are allowed try to recognize the input for this one.
	                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	                //      that is being recognized.
	                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	                //      this can be setup with the `recognizeWith()` method on the recognizer.
	                if (session.stopped !== FORCED_STOP && ( // 1
	                !curRecognizer || recognizer == curRecognizer || // 2
	                recognizer.canRecognizeWith(curRecognizer))) {
	                    // 3
	                    recognizer.recognize(inputData);
	                } else {
	                    recognizer.reset();
	                }
	
	                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	                // current active recognizer. but only if we don't already have an active recognizer
	                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                    curRecognizer = session.curRecognizer = recognizer;
	                }
	                i++;
	            }
	        },
	
	        /**
	         * get a recognizer by its event name.
	         * @param {Recognizer|String} recognizer
	         * @returns {Recognizer|Null}
	         */
	        get: function get(recognizer) {
	            if (recognizer instanceof Recognizer) {
	                return recognizer;
	            }
	
	            var recognizers = this.recognizers;
	            for (var i = 0; i < recognizers.length; i++) {
	                if (recognizers[i].options.event == recognizer) {
	                    return recognizers[i];
	                }
	            }
	            return null;
	        },
	
	        /**
	         * add a recognizer to the manager
	         * existing recognizers with the same event name will be removed
	         * @param {Recognizer} recognizer
	         * @returns {Recognizer|Manager}
	         */
	        add: function add(recognizer) {
	            if (invokeArrayArg(recognizer, 'add', this)) {
	                return this;
	            }
	
	            // remove existing
	            var existing = this.get(recognizer.options.event);
	            if (existing) {
	                this.remove(existing);
	            }
	
	            this.recognizers.push(recognizer);
	            recognizer.manager = this;
	
	            this.touchAction.update();
	            return recognizer;
	        },
	
	        /**
	         * remove a recognizer by name or instance
	         * @param {Recognizer|String} recognizer
	         * @returns {Manager}
	         */
	        remove: function remove(recognizer) {
	            if (invokeArrayArg(recognizer, 'remove', this)) {
	                return this;
	            }
	
	            recognizer = this.get(recognizer);
	
	            // let's make sure this recognizer exists
	            if (recognizer) {
	                var recognizers = this.recognizers;
	                var index = inArray(recognizers, recognizer);
	
	                if (index !== -1) {
	                    recognizers.splice(index, 1);
	                    this.touchAction.update();
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * bind event
	         * @param {String} events
	         * @param {Function} handler
	         * @returns {EventEmitter} this
	         */
	        on: function on(events, handler) {
	            if (events === undefined) {
	                return;
	            }
	            if (handler === undefined) {
	                return;
	            }
	
	            var handlers = this.handlers;
	            each(splitStr(events), function (event) {
	                handlers[event] = handlers[event] || [];
	                handlers[event].push(handler);
	            });
	            return this;
	        },
	
	        /**
	         * unbind event, leave emit blank to remove all handlers
	         * @param {String} events
	         * @param {Function} [handler]
	         * @returns {EventEmitter} this
	         */
	        off: function off(events, handler) {
	            if (events === undefined) {
	                return;
	            }
	
	            var handlers = this.handlers;
	            each(splitStr(events), function (event) {
	                if (!handler) {
	                    delete handlers[event];
	                } else {
	                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
	                }
	            });
	            return this;
	        },
	
	        /**
	         * emit event to the listeners
	         * @param {String} event
	         * @param {Object} data
	         */
	        emit: function emit(event, data) {
	            // we also want to trigger dom events
	            if (this.options.domEvents) {
	                triggerDomEvent(event, data);
	            }
	
	            // no handlers, so skip it all
	            var handlers = this.handlers[event] && this.handlers[event].slice();
	            if (!handlers || !handlers.length) {
	                return;
	            }
	
	            data.type = event;
	            data.preventDefault = function () {
	                data.srcEvent.preventDefault();
	            };
	
	            var i = 0;
	            while (i < handlers.length) {
	                handlers[i](data);
	                i++;
	            }
	        },
	
	        /**
	         * destroy the manager and unbinds all events
	         * it doesn't unbind dom events, that is the user own responsibility
	         */
	        destroy: function destroy() {
	            this.element && toggleCssProps(this, false);
	
	            this.handlers = {};
	            this.session = {};
	            this.input.destroy();
	            this.element = null;
	        }
	    };
	
	    /**
	     * add/remove the css properties as defined in manager.options.cssProps
	     * @param {Manager} manager
	     * @param {Boolean} add
	     */
	    function toggleCssProps(manager, add) {
	        var element = manager.element;
	        if (!element.style) {
	            return;
	        }
	        var prop;
	        each(manager.options.cssProps, function (value, name) {
	            prop = prefixed(element.style, name);
	            if (add) {
	                manager.oldCssProps[prop] = element.style[prop];
	                element.style[prop] = value;
	            } else {
	                element.style[prop] = manager.oldCssProps[prop] || '';
	            }
	        });
	        if (!add) {
	            manager.oldCssProps = {};
	        }
	    }
	
	    /**
	     * trigger dom event
	     * @param {String} event
	     * @param {Object} data
	     */
	    function triggerDomEvent(event, data) {
	        var gestureEvent = document.createEvent('Event');
	        gestureEvent.initEvent(event, true, true);
	        gestureEvent.gesture = data;
	        data.target.dispatchEvent(gestureEvent);
	    }
	
	    assign(Hammer, {
	        INPUT_START: INPUT_START,
	        INPUT_MOVE: INPUT_MOVE,
	        INPUT_END: INPUT_END,
	        INPUT_CANCEL: INPUT_CANCEL,
	
	        STATE_POSSIBLE: STATE_POSSIBLE,
	        STATE_BEGAN: STATE_BEGAN,
	        STATE_CHANGED: STATE_CHANGED,
	        STATE_ENDED: STATE_ENDED,
	        STATE_RECOGNIZED: STATE_RECOGNIZED,
	        STATE_CANCELLED: STATE_CANCELLED,
	        STATE_FAILED: STATE_FAILED,
	
	        DIRECTION_NONE: DIRECTION_NONE,
	        DIRECTION_LEFT: DIRECTION_LEFT,
	        DIRECTION_RIGHT: DIRECTION_RIGHT,
	        DIRECTION_UP: DIRECTION_UP,
	        DIRECTION_DOWN: DIRECTION_DOWN,
	        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	        DIRECTION_ALL: DIRECTION_ALL,
	
	        Manager: Manager,
	        Input: Input,
	        TouchAction: TouchAction,
	
	        TouchInput: TouchInput,
	        MouseInput: MouseInput,
	        PointerEventInput: PointerEventInput,
	        TouchMouseInput: TouchMouseInput,
	        SingleTouchInput: SingleTouchInput,
	
	        Recognizer: Recognizer,
	        AttrRecognizer: AttrRecognizer,
	        Tap: TapRecognizer,
	        Pan: PanRecognizer,
	        Swipe: SwipeRecognizer,
	        Pinch: PinchRecognizer,
	        Rotate: RotateRecognizer,
	        Press: PressRecognizer,
	
	        on: addEventListeners,
	        off: removeEventListeners,
	        each: each,
	        merge: merge,
	        extend: extend,
	        assign: assign,
	        inherit: inherit,
	        bindFn: bindFn,
	        prefixed: prefixed
	    });
	
	    // this prevents errors when Hammer is loaded in the presence of an AMD
	    //  style loader but by script tag, not by the loader.
	    var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line
	    freeGlobal.Hammer = Hammer;
	
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Hammer;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module != 'undefined' && module.exports) {
	        module.exports = Hammer;
	    } else {
	        window[exportName] = Hammer;
	    }
	})(window, document, 'Hammer');

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(18)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ut, Gator) {
	
		// Every button should have an :after pseudo-element tooltip prebuilt in CSS.
		(function () {
			var inspectingTooltips = false;
			var waitingPeriod = void 0;
			var allowanceInterval = void 0;
			var elementStack = [];
	
			Gator(document.body).on("mouseover", ".panel__button", function (e) {
	
				// Technically unnecessary but DOM call seems to suppress glitching.
				if (this.classList.contains("panel__button--show-tooltip")) {
					return;
				}
	
				var button = this;
	
				// Once tooltips are shown, allow the user to scan quickly between tooltips
				// without delay
				var delay = 1000;
				if (inspectingTooltips) {
					delay = 0;
				}
	
				// Throttle multiple mouseover events.
				clearTimeout(waitingPeriod);
	
				// Still inspecting, don't set false yet
				clearTimeout(allowanceInterval);
	
				waitingPeriod = setTimeout(function () {
					addTooltip(button);
				}, delay);
				button.addEventListener("mouseleave", abortTooltip);
			});
	
			var addTooltip = function addTooltip(buttonElem) {
				inspectingTooltips = true;
				waitingPeriod = null;
	
				// Tooltips need to float above any adjacent panels, so
				// move the current panel to the stop of the stack.
				var parentPanel = ut.getClosest(buttonElem, ".panel");
				shufflePanelStack(parentPanel);
	
				buttonElem.classList.add("panel__button--show-tooltip");
			};
	
			var abortTooltip = function abortTooltip() {
	
				// In case the mouse darts in and out, before the tooltip is ever shown.
				clearTimeout(waitingPeriod);
				this.classList.remove("panel__button--show-tooltip");
				this.removeEventListener("mouseleave", abortTooltip);
				allowanceInterval = setTimeout(function () {
					inspectingTooltips = false;
				}, 200);
			};
	
			//
			// Panel Stacking on click
			//
			// Grouped with Tooltips because tooltip show sometimes needs to lift hovered button's
			// panel in the stacking order.
			var getLayerNumber = function getLayerNumber(elem) {
				for (var i = 0; i < elementStack.length; i += 1) {
					if (elem === elementStack[i]) {
						return i;
					}
				}
			};
	
			var applyZindexClasses = function applyZindexClasses() {
				var elem = void 0;
				var len = elementStack.length;
				if (!len) {
					return;
				}
	
				for (var i = 0; i < len; i += 1) {
					elem = elementStack[i];
	
					if (elem) {
						// Some mobile-only buttons float free & don't live in a panel.
	
						// Remove all the old class names.
						for (var j = 0; j < len; j += 1) {
							elem.classList.remove("z-index" + (j + 1));
						}
	
						// And apply the new.
						elem.classList.add("z-index" + (i + 1));
					}
				}
			};
	
			var shufflePanelStack = function shufflePanelStack(panelToGoOnTop) {
	
				// If click is on the topmost layer get out.
				if (panelToGoOnTop === elementStack[elementStack.length - 1]) {
					return;
				}
	
				var currentLayerNumber = getLayerNumber(panelToGoOnTop);
	
				if (typeof currentLayerNumber === "number") {
	
					// Remove from current position.
					elementStack.splice(currentLayerNumber, 1);
				}
	
				// Always apply classes to any panel that has been clicked
				elementStack.push(panelToGoOnTop);
				applyZindexClasses();
			};
	
			Gator(document.body).on("mousedown", ".panel", function () {
				shufflePanelStack(this);
			});
		})();
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright 2014 Craig Campbell
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * GATOR.JS
	 * Simple Event Delegation
	 *
	 * @version 1.2.4
	 *
	 * Compatible with IE 9+, FF 3.6+, Safari 5+, Chrome
	 *
	 * Include legacy.js for compatibility with older browsers
	 *
	 *             .-._   _ _ _ _ _ _ _ _
	 *  .-''-.__.-'00  '-' ' ' ' ' ' ' ' '-.
	 * '.___ '    .   .--_'-' '-' '-' _'-' '._
	 *  V: V 'vv-'   '_   '.       .'  _..' '.'.
	 *    '=.____.=_.--'   :_.__.__:_   '.   : :
	 *            (((____.-'        '-.  /   : :
	 *                              (((-'\ .' /
	 *                            _____..'  .'
	 *                           '-._____.-'
	 */
	(function () {
	    var _matcher,
	        _level = 0,
	        _id = 0,
	        _handlers = {},
	        _gatorInstances = {};
	
	    function _addEvent(gator, type, callback) {
	
	        // blur and focus do not bubble up but if you use event capturing
	        // then you will get them
	        var useCapture = type == 'blur' || type == 'focus';
	        gator.element.addEventListener(type, callback, useCapture);
	    }
	
	    function _cancel(e) {
	        e.preventDefault();
	        e.stopPropagation();
	    }
	
	    /**
	     * returns function to use for determining if an element
	     * matches a query selector
	     *
	     * @returns {Function}
	     */
	    function _getMatcher(element) {
	        if (_matcher) {
	            return _matcher;
	        }
	
	        if (element.matches) {
	            _matcher = element.matches;
	            return _matcher;
	        }
	
	        if (element.webkitMatchesSelector) {
	            _matcher = element.webkitMatchesSelector;
	            return _matcher;
	        }
	
	        if (element.mozMatchesSelector) {
	            _matcher = element.mozMatchesSelector;
	            return _matcher;
	        }
	
	        if (element.msMatchesSelector) {
	            _matcher = element.msMatchesSelector;
	            return _matcher;
	        }
	
	        if (element.oMatchesSelector) {
	            _matcher = element.oMatchesSelector;
	            return _matcher;
	        }
	
	        // if it doesn't match a native browser method
	        // fall back to the gator function
	        _matcher = Gator.matchesSelector;
	        return _matcher;
	    }
	
	    /**
	     * determines if the specified element matches a given selector
	     *
	     * @param {Node} element - the element to compare against the selector
	     * @param {string} selector
	     * @param {Node} boundElement - the element the listener was attached to
	     * @returns {void|Node}
	     */
	    function _matchesSelector(element, selector, boundElement) {
	
	        // no selector means this event was bound directly to this element
	        if (selector == '_root') {
	            return boundElement;
	        }
	
	        // if we have moved up to the element you bound the event to
	        // then we have come too far
	        if (element === boundElement) {
	            return;
	        }
	
	        // if this is a match then we are done!
	        if (_getMatcher(element).call(element, selector)) {
	            return element;
	        }
	
	        // if this element did not match but has a parent we should try
	        // going up the tree to see if any of the parent elements match
	        // for example if you are looking for a click on an <a> tag but there
	        // is a <span> inside of the a tag that it is the target,
	        // it should still work
	        if (element.parentNode) {
	            _level++;
	            return _matchesSelector(element.parentNode, selector, boundElement);
	        }
	    }
	
	    function _addHandler(gator, event, selector, callback) {
	        if (!_handlers[gator.id]) {
	            _handlers[gator.id] = {};
	        }
	
	        if (!_handlers[gator.id][event]) {
	            _handlers[gator.id][event] = {};
	        }
	
	        if (!_handlers[gator.id][event][selector]) {
	            _handlers[gator.id][event][selector] = [];
	        }
	
	        _handlers[gator.id][event][selector].push(callback);
	    }
	
	    function _removeHandler(gator, event, selector, callback) {
	
	        // if there are no events tied to this element at all
	        // then don't do anything
	        if (!_handlers[gator.id]) {
	            return;
	        }
	
	        // if there is no event type specified then remove all events
	        // example: Gator(element).off()
	        if (!event) {
	            for (var type in _handlers[gator.id]) {
	                if (_handlers[gator.id].hasOwnProperty(type)) {
	                    _handlers[gator.id][type] = {};
	                }
	            }
	            return;
	        }
	
	        // if no callback or selector is specified remove all events of this type
	        // example: Gator(element).off('click')
	        if (!callback && !selector) {
	            _handlers[gator.id][event] = {};
	            return;
	        }
	
	        // if a selector is specified but no callback remove all events
	        // for this selector
	        // example: Gator(element).off('click', '.sub-element')
	        if (!callback) {
	            delete _handlers[gator.id][event][selector];
	            return;
	        }
	
	        // if we have specified an event type, selector, and callback then we
	        // need to make sure there are callbacks tied to this selector to
	        // begin with.  if there aren't then we can stop here
	        if (!_handlers[gator.id][event][selector]) {
	            return;
	        }
	
	        // if there are then loop through all the callbacks and if we find
	        // one that matches remove it from the array
	        for (var i = 0; i < _handlers[gator.id][event][selector].length; i++) {
	            if (_handlers[gator.id][event][selector][i] === callback) {
	                _handlers[gator.id][event][selector].splice(i, 1);
	                break;
	            }
	        }
	    }
	
	    function _handleEvent(id, e, type) {
	        if (!_handlers[id][type]) {
	            return;
	        }
	
	        var target = e.target || e.srcElement,
	            selector,
	            match,
	            matches = {},
	            i = 0,
	            j = 0;
	
	        // find all events that match
	        _level = 0;
	        for (selector in _handlers[id][type]) {
	            if (_handlers[id][type].hasOwnProperty(selector)) {
	                match = _matchesSelector(target, selector, _gatorInstances[id].element);
	
	                if (match && Gator.matchesEvent(type, _gatorInstances[id].element, match, selector == '_root', e)) {
	                    _level++;
	                    _handlers[id][type][selector].match = match;
	                    matches[_level] = _handlers[id][type][selector];
	                }
	            }
	        }
	
	        // stopPropagation() fails to set cancelBubble to true in Webkit
	        // @see http://code.google.com/p/chromium/issues/detail?id=162270
	        e.stopPropagation = function () {
	            e.cancelBubble = true;
	        };
	
	        for (i = 0; i <= _level; i++) {
	            if (matches[i]) {
	                for (j = 0; j < matches[i].length; j++) {
	                    if (matches[i][j].call(matches[i].match, e) === false) {
	                        Gator.cancel(e);
	                        return;
	                    }
	
	                    if (e.cancelBubble) {
	                        return;
	                    }
	                }
	            }
	        }
	    }
	
	    /**
	     * binds the specified events to the element
	     *
	     * @param {string|Array} events
	     * @param {string} selector
	     * @param {Function} callback
	     * @param {boolean=} remove
	     * @returns {Object}
	     */
	    function _bind(events, selector, callback, remove) {
	
	        // fail silently if you pass null or undefined as an alement
	        // in the Gator constructor
	        if (!this.element) {
	            return;
	        }
	
	        if (!(events instanceof Array)) {
	            events = [events];
	        }
	
	        if (!callback && typeof selector == 'function') {
	            callback = selector;
	            selector = '_root';
	        }
	
	        var id = this.id,
	            i;
	
	        function _getGlobalCallback(type) {
	            return function (e) {
	                _handleEvent(id, e, type);
	            };
	        }
	
	        for (i = 0; i < events.length; i++) {
	            if (remove) {
	                _removeHandler(this, events[i], selector, callback);
	                continue;
	            }
	
	            if (!_handlers[id] || !_handlers[id][events[i]]) {
	                Gator.addEvent(this, events[i], _getGlobalCallback(events[i]));
	            }
	
	            _addHandler(this, events[i], selector, callback);
	        }
	
	        return this;
	    }
	
	    /**
	     * Gator object constructor
	     *
	     * @param {Node} element
	     */
	    function Gator(element, id) {
	
	        // called as function
	        if (!(this instanceof Gator)) {
	            // only keep one Gator instance per node to make sure that
	            // we don't create a ton of new objects if you want to delegate
	            // multiple events from the same node
	            //
	            // for example: Gator(document).on(...
	            for (var key in _gatorInstances) {
	                if (_gatorInstances[key].element === element) {
	                    return _gatorInstances[key];
	                }
	            }
	
	            _id++;
	            _gatorInstances[_id] = new Gator(element, _id);
	
	            return _gatorInstances[_id];
	        }
	
	        this.element = element;
	        this.id = id;
	    }
	
	    /**
	     * adds an event
	     *
	     * @param {string|Array} events
	     * @param {string} selector
	     * @param {Function} callback
	     * @returns {Object}
	     */
	    Gator.prototype.on = function (events, selector, callback) {
	        return _bind.call(this, events, selector, callback);
	    };
	
	    /**
	     * removes an event
	     *
	     * @param {string|Array} events
	     * @param {string} selector
	     * @param {Function} callback
	     * @returns {Object}
	     */
	    Gator.prototype.off = function (events, selector, callback) {
	        return _bind.call(this, events, selector, callback, true);
	    };
	
	    Gator.matchesSelector = function () {};
	    Gator.cancel = _cancel;
	    Gator.addEvent = _addEvent;
	    Gator.matchesEvent = function () {
	        return true;
	    };
	
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports = Gator;
	    }
	
	    window.Gator = Gator;
	})();

/***/ }
/******/ ]);
//# sourceMappingURL=app.min.js.map